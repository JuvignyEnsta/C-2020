\chapter{Initiation au C++}

Nous allons attaquer dans ce chap√Ætre la programmation en C++. Pour ceux rompu aux arcanes du C, beaucoup de passages
de ce chap√Ætre seront des rappels du C, mais ce chap√Ætre contient √©galement son lot de nouveaut√©s par rapport aux
langage C. Aussi n'est-il pas conseill√© de sauter ce chap√Ætre m√™me si le C n'a plus de secret pour vous. Passez simplement les passages √©voquant des sp√©cificit√©s communs au C et C++.

De m√™me, ce chap√Ætre ne changera pas fondamentalement votre paradigme de programmation, vous pouvez simple le voir comme un chap√Ætre pr√©sentant un langage C "am√©lior√©".

Enfin, ce chap√Ætre, ainsi que le reste du cours, n'a pas vocation √† vous pr√©senter le C++ de A √† Z. Ce serait tr√®s ambitieux de la part de l'auteur, voire impossible √† r√©aliser. Le cr√©ateur du C++, le Dr. Bjarn Stroustrup d√©clare lui-m√™me ne conna√Ætre que 70\% du langage C++ ! Un d√©butant conna√Æt environ 10\% du langage et un expert 60\% du langage.

Il ne faut donc pas h√©siter √† se documenter, en particuliers sur internet. Pour avoir une documentation de r√©f√©rence (pas pour apprendre), on peut se r√©f√©rer aux deux sites suivants (en anglais) :

\begin{itemize}
    \item \url{https://en.cppreference.com/w/}
    \item \url{http://www.cplusplus.com/}
\end{itemize}

\section{Les blocs d'instruction}

Comme son nom le laisse entendre, le bloc d'instruction est un "bloc" contenant une ou plusieurs instructions. En C et C++, le bloc commence par une accolade ouvrante et se termine par une accolade fermante. L'exemple ci--dessous vous montre un bloc d'instructions demandant votre nom et l'affichant sur la console.

\begin{lstlisting}[caption=Exemple de bloc d'instructions]
{
  printf("Veuillez rentrer votre nom s'il vous plait : ");
  char buffer[256];
  scanf("%255s", buffer);
  printf("Bonjour %s\n", buffer);
}
\end{lstlisting}

Un bloc d'instruction peut lui-m√™me contenir un bloc d'instruction. On parle alors de sous-blocs d'instruction.

\section{Et pour commencer : un petit programme "Hello world"}

Nous allons commencer par diss√©quer un petit programme affichant "Hello world" sur une console. Voici le programme :
\begin{lstlisting}[stepnumber=1,caption=Un programme Hello World !]
#include <iostream>

int main()
{
    std::cout << "Hello World !" << std::endl;
    return EXIT_SUCCESS;
}
\end{lstlisting}

\begin{itemize}
  \item[$1^{\mbox{√®re}}$ ligne] : |#include| est une instruction demandant au compilateur de "charger" des instructions ou des nouveaux types (du moins leurs d√©clarations) permettant d'√©tendre les possibilit√©s du langage. Ici, nous demandons au compilateur de charger une "biblioth√®que" |iostream| (\textbf{i}nput \textbf{o}utput \textbf{stream}) qui permet d'afficher sur l'√©cran divers messages. Il faut en effet savoir que les instructions de base du C++ (comme pour le C) ne permettent pas d'afficher un quelconque message √† l'√©cran. Il faut pour cela utiliser une "biblioth√®que" permettant d'√©tendre les possibilit√©s du langage de base. Les symboles \verb@<@ et \verb@>@ autour de |iostream| signifie que cette biblioth√®que est une biblioth√®que externe, c'est √† dire une biblioth√®que qui n'est pas d√©finie dans le m√™me espace de travail que le programme. Ici, la biblioth√®que |iostream| est une biblioth√®que standard du C++ faisant partie du standard ISO (et qu'on retrouve donc pour tous les compilateurs compatibles avec la norme internationale);
  \item[$3^{e}$ ligne] : Elle d√©finit une "fonction sp√©ciale" |int main()| (on verra plus loin ce qu'est une fonction en C++), qui sert de point d'entr√©e pour l'ex√©cution du programme, c'est √† dire qu'√† l'√©x√©cution du programme compil√©, l'ordinateur commencera √† ex√©cuter les instructions se trouvant dans le bloc d'instruction de la fonction |main| (ce qui se trouve dans les accolades juste en dessous de |int main()|. Un programme C++ contiendra toujours une et une seule fonction |main| qui servira d'unique point d'entr√©e lors de l'ex√©cution du programme compil√©. Cette fonction renvoie toujours en entier (|int|)  au sysst√®me pour lui signaler si l'ex√©cution s'est bien d√©roul√©e ou non.
  \item[$4^{e}$ ligne] : On reconna√Æt ensuite le d√©but d'un bloc d'instruction, qui correspond ici au bloc d'instruction que doit ex√©cuter l'ordinateur lorsqu'il rentre dans la fonction |main| √† l'ex√©cution. La fin du bloc d'instruction se trouve √† la ligne sept.
  \item [$5^{e}$ ligne] : On demande √† l'ordinateur d'afficher "Hello World !" sur une console (celle √† partir de laquelle on a lanc√© le programme). |std::cout| d√©clare qu'on veut afficher un message sur une console (|cout| est une contraction de \textbf{c}onsole \textbf{out}put), le symbole \verb@<<@ indique qu'on veut rediriger un flux de messages vers cette console pour les afficher (les messages se trouvant √† droite du symbole \verb@<<@). Le premier message √† rediriger vers la console est une cha√Æne de caract√®res contenant le message "Hello World !", le message √©tant entour√© par des guillemets, puis afin de rediriger un second message sur la console, on reutilise le symbole \verb@<<@ qui s'encha√Æne avec le premier \verb@<<@. Enfin on d√©finit le second (et dernier) message comme √©tant, \verb@std::endl@, qui est une instruction d'affichage demandant d'afficher tous les messages redirig√©s auparavant et de passer √† la ligne suivante sur la console (|endl| est une contraction de \textbf{end} \textbf{l}ine). Enfin, le symbole \verb@;@ signifie qu'on a terminer de d√©finir une instruction (Il faut mettre un |;| √† la fin de chaque instruction en C++).
  \item [$6^{e}$ ligne] : On demande au programme de renvoyer une valeur \verb@EXIT_SUCCESS@ d√©finie dans la biblioth√®que |cstdlib| elle-m√™me utilis√©e par |iostream|, et qui signale au syst√®me que l'ex√©cution du programme s'est bien pass√©e (en cas d'erreur ou de probl√®me rencontr√© dans le programme, on aurait pu retourner \verb@EXIT_FAILURE@).
\end{itemize}

\section{Headers et fichiers sources}

Un projet C++ contiendra principalement deux types de fichiers : les headers et les fichiers sources.

Par convention, les headers propre au projet auront pour extension |.hpp|. Par exemple
\begin{verbatim}
polynomes.hpp
rationnel.hpp
matrice.hpp
\end{verbatim}

Les headers contiendront la d√©finition de nouveaux types et la d√©claration de fonctions, c'est √† dire l'inventaire
des "instructions" que l'on rajoute au langage avec les param√®tres attendus et quel type de valeurs est retourn√©.

On y reviendra sur le chap√Ætre des fonctions.

Les fichiers sources auront pour convention l'extension |.cpp|. Par exemple :
\begin{verbatim}
polynomes.cpp
rationnel.cpp
matrice.cpp
\end{verbatim}

Les fichiers sources contiennes le code d√©crivant les algorithmes permettant de r√©pondre √† ce que sont cens√©s faire les fonctions d√©clar√©s dans le header correspondant (sauf pour celui contenant la fonction main qui n'a pas de header correspondant).

Par exemple, construisons une biblioth√®que qui permet de calculer le carr√© d'un entier. On cr√©e d'abord le header |carre.hpp| qui nous permettra de sp√©cifier une interface, c'est √† dire quel sera le nom de la fonction, les types des valeurs attendues et le type de valeur retourn√©e :

\begin{lstlisting}
#ifndef _CARRE_HPP_
#define _CARRE_HPP_

int carre(int n);

#endif
\end{lstlisting}

Les deux premi√®res lignes ainsi que la derni√®re sont utiles pour s'assurer qu'un fichier source, de fa√ßon directe ou indirecte, inclut plusieurs fois la d√©claration de la fonction |carre|. Outre un gain non n√©gligeable en temps de compilation, il se trouve √©galement que le C++ n'aime pas qu'on d√©clare plusieurs fois la m√™me fonction.

Ensuite vient la d√©finition de la fonction, qui comprend : le type de valeur qu'elle retourne, son nom et le type de param√®tre qu'elle attend. On n'√©crit ici aucun algorithme d√©crivant comment nous allons calculer le carr√© de n ! On termine la d√©claration par un point virgule.

On cr√©e ensuite le fichier source correspondant, |carre.cpp| qui d√©crira la fonction avec un algorithme permettant de calculer le carr√© de n. Bien que cela ne soit pas obligatoire, il est conseill√© d'inclure |carre.h| pour s'assurer qu'on conserve bien la m√™me interface que celle d√©clar√©e dans le header !

\begin{lstlisting}
#include "carre.hpp"

int carre(int n)
{
  return n*n;
}
\end{lstlisting}

Le bloc d'instruction juste en dessous de la fonction (sans point virgule √† la fin de la ligne !), d√©crit en langage C++ l'algorithme qui calcule le carr√© de n et le retourne en sortie de la fonction.

Pour appeler cette fonction, il suffit d'√©crire une ligne du type
\begin{lstlisting}[caption=Exemple d'utilisation de la fonction]
int res = carre(5);
\end{lstlisting}

qui appelle la fonction avec le param√®tre cinq et renvoie la valeur vingt-cinq qu'on rangera dans la variable res.

En C++, on a aussi parfois besoin d'autres types de fichiers, qui essentiellement contiennent des lignes devant se trouver dans un header mais qui pour une raison ou une autre peut √™tre mise dans un autre fichier. Pour ces fichiers, soit on garde le protocole de rajouter le suffixe |.hpp| soit on choisit une autre extension, mais dans ce cas, rien de normalis√© existe.

\section{Les variables}

Les variables sont des noms (symboles) auxquelles on associe des valeurs. Ces valeurs peuvent changer au cours du temps (mais ce n'est pas obligatoire, les variables dans les langages fonctionnels ne peuvent changer de valeurs).


\subsection{Convention sur le nom des variables}

Le nommage des variables (mais √©galement des structures, des classes, des fonctions qu'on verra plus loin) est assez souple mais doit ob√©ir tout de m√™me √† certaines r√®gles.

Une variable ne doit pas contenir :
\begin{itemize}
  \item Un espace ou une tabulation
  \item Une ponctuation (\verb@, ; . : ! ? # \@);
  \item Des simples ou double quotes (\verb@'@ ou \verb@"@);
  \item Des symboles servant √† d√©finir des op√©rateurs (\verb@+ - ^ / * | &@);
  \item Des parenth√®ses, bracket ou accolades \verb@( [ { } ] )@;
  \item Les symboles \verb!@! et \copyright.
\end{itemize}

Une variable ne doit pas √©galement commencer par un chiffre.

Par contre, un caract√®re peut contenir toute lettre de l'alphabet (accents compris), ainsi qu'une grande partie des caract√®res unicodes (alphabet grecque, japonais, indou, etc. ).

Ainsi, les noms suivants sont valides : \texttt{a, \_a, $\pi$, $\zeta$, cl√©, p√©rim√®tre},\ldots

Les noms suivants \textcolor{red}{\bf ne sont pas valides} : \verb@3a, {z, !b, la clef@

Utiliser des lettres autres que les lettres anglosaxonnes ne posent aucun soucis de portabilit√©, car cela fait partie de la norme C++ depuis 2011, tant que l'√©diteur que vous utilisez supporte l'√©dition en unicode, ce qui est le cas de la grande majorit√© des √©diteurs de texte aujourd'hui. Les compilateurs Intel, Gnu, Clang et Microsoft supportent les variables nomm√©es avec des caract√®res unicode (pour gcc, ce n'est que depuis la version 10 du compilateur !).

\underline{Ce qui dit exactement la norme C++ 11 :}
Un identifieur pour une variable est une s√©quence arbitrairement longue de lettres et de chiffres. Chaque caract√®re universel dans un identifieur devra √™tre une lettre qui respecte la norme ISO 10646 et √™tre un caract√®re comme sp√©cifi√© dans E.1. L'√©l√©ment inital ne devra pas √™tre un caract√®re universel qui appartient aux ensembles d√©sign√©s par E.2. Les lettres minuscules et majuscules sont diff√©rentes. Tout les caract√®res sont sp√©cifiques.

\textbf{E.1} liste les caract√®res permis dont font parti les lettres grecques, les lettres accentu√©es mais aussi des caract√®res comme \verb@¬™ ¬Ø ¬≤ ¬≥ ¬¥ ¬µ ¬∑  ¬π ¬∫ ¬º ¬Ω ¬æ √ò ¬∞ √ñ  êÄÄ@ \\
\textbf{E.2} liste les caract√®res qui ne sont pas permis en premi√®re lettre dans l'identifieur d'une variable, √† savoir les chiffres, et ce qui peut ressembler √† des quotes.

Pour plus de pr√©cision, voir le draft ISO C++ 11 (\url{https://isocpp.org/files/papers/n4296.pdf} √† la page 1265).


\subsection{D√©claration}

Une variable est d√©finie par son \textbf{type} (un r√©el, un entier, une cha√Æne de caract√®re, un tableau, etc. ) suivi du nom de la variable. Les variables peuvent √™tre d√©clar√©es √† n'importe quel endroit du code. Une variable n'existe qu'au sein du bloc d'instruction dans lequel elle est d√©clar√©e. Elle ne sera en outre visible que dans ce bloc d'instruction ou dans les sous-blocs d'instruction contenus dans le bloc d'instruction.

Il faut savoir que chaque variable d√©clar√©e dans un bloc d'instruction est stock√©e dans une zone m√©moire particuli√®re du programme nomm√©e \textsl{pile d'ex√©cution}. L'√©tat de cette pile √©volue au cours du temps en fonction des variables que l'on a d√©fini.

Ainsi par exemple (|int| d√©clarant le type de la variable comme un entier) :

\begin{lstlisting}[stepnumber=1,caption=Exemple de pile d'ex√©cution]
{
  int a;
  {
    int b = 3;
    a = 2;
    int c = 4;
    b = 5;
  }
  a= 8;
}
\end{lstlisting}

aura pour pile d'ex√©cution :

\begin{tabular}{|c||c|c|c|c|c|c|c|c|c|c|}\hline
Num√©ro de ligne & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\ \hline\hline
\multirow{4}{*}{Pile} & & & & & & & & & & \\
\cline{2-11} &   &   &   &   &   &c=4&c=4&   &   &    \\
\cline{2-11} &   &   &   &b=3&b=3&b=3&b=5&   &   &    \\
\cline{2-11} &   & a & a & a &a=2&a=2&a=2&a=2&a=8&    \\ \hline
\end{tabular}

On voit que les variables s'entassent sur la pile et disparaissent d√®s qu'on quitte le bloc d'instruction o√π elles ont √©t√© d√©clar√©es. 

Si une variable est d√©clar√©e en dehors de tout bloc d'instruction, c'est une variable \textsl{globale} qui aura une dur√©e de vie aussi longue que l'ex√©cution du code lui-m√™me. Elle sera alors visible par tous les blocs d'instructions. Il est fort peu recommand√© d'utiliser les variables globales car elles peuvent √™tre g√©n√©ratrices de nombreux bogues, en particulier dans un contexte multi-threads (qu'on verra dans le cours de l'ann√©e prochaine).

\subsection{Types scalaires}

Les types scalaires sont des types de variables repr√©sentant des nombres entiers ou r√©els, voire complexes. 

\subsubsection{Le type bool√©en}

Le type bool√©en est un type de variable ne pouvant prendre que deux valeurs : vrai ou faux. On d√©clare une variable bool√©enne
en C++ √† l'aide du mot clef |bool| et les valeurs vrai ou faux correspondent respectivement aux mots clefs |true| et |false|.

\begin{lstlisting}
bool flag = true; // La variable flag est mise √† vraie
flag = false;
\end{lstlisting}

Il est possible de faire des op√©rations logiques sur les bool√©ens, √† savoir :
\begin{itemize}
  \item \textcolor{red}{OU logique} (symbole \verb@|@) : \verb@f1 || f2@
  Cet op√©ration renvoie vrai si au moins une des deux valeurs est vraie (voir la table de v√©rit√© \ref{tab::or_logical_table})

  \begin{table}[h]
  \begin{center}
  \begin{tabular}{ccc}\hline
  Valeur de f1 & Valeur de f2 & Valeur de \verb@f1 || f2@ \\ \hline\hline
      |false|  &   |false|    &    |false| \\ \hline
      |true|   &   |false|    &    |true|  \\ \hline
      |false|  &   |true|     &    |true|  \\ \hline
      |true|   &   |true|     &    |true|  \\ \hline
  \end{tabular}
  \end{center}
  \caption{Table de v√©rit√© de l'op√©rateur OU logique}
  \label{tab::or_logical_table}
  \end{table}

  \item \textcolor{red}{ET logique} (symbole \verb@&&@) : \verb@f1 && f2@
  Cet op√©ration renvoie vrai si et seulement si les deux valeurs sont vraies (voir la tableau de v√©rit√©
  \ref{tab::and_logical_table})

  \begin{table}[h]
  \begin{center}
  \begin{tabular}{ccc}\hline
  Valeur de f1 & Valeur de f2 & Valeur de \verb@f1 && f2@ \\ \hline\hline
      |false|  &   |false|    &    |false| \\ \hline
      |true|   &   |false|    &    |false| \\ \hline
      |false|  &   |true|     &    |false| \\ \hline
      |true|   &   |true|     &    |true|  \\ \hline
  \end{tabular}
  \end{center}
  \caption{Table de v√©rit√© de l'op√©rateur ET logique}
  \label{tab::and_logical_table}
  \end{table}

  \item \textcolor{red}{OU EXCLUSIF} (symbole \verb@^@) : \verb@f1 ^ f2@
  Cet op√©ration renvoie vrai si une seule des deux valeurs est vraie (et l'autre fausse)
  (voir la table de v√©rit√© \ref{tab::xor_logical_table})

  \begin{table}[h]
  \begin{center}
  \begin{tabular}{ccc}\hline
  Valeur de f1 & Valeur de f2 & Valeur de \verb@f1 ^ f2@ \\ \hline\hline
      |false|  &   |false|    &    |false| \\ \hline
      |true|   &   |false|    &    |true|  \\ \hline
      |false|  &   |true|     &    |true|  \\ \hline
      |true|   &   |true|     &    |false| \\ \hline
  \end{tabular}
  \end{center}
  \caption{Table de v√©rit√© de l'op√©rateur OU exclusif}
  \label{tab::xor_logical_table}
  \end{table}

  \item \textcolor{red}{NON logique} (symbole \verb@!@) : \verb@!f1@
  Cet op√©ration renvoie faux si la valeur est vraie et vraie si la valeur est fausse
  (voir la table de v√©rit√© \ref{tab::not_logical_table})

  \begin{table}[h]
  \begin{center}
  \begin{tabular}{cc}\hline
  Valeur de f & Valeur de \verb@!f@ \\ \hline \hline
     |false|  &    |true| \\ \hline
     |true|   &    |false|\\ \hline
  \end{tabular}
  \end{center}
  \caption{Table de v√©rit√© de l'op√©rateur NON logique}
  \label{tab::not_logical_table}
  \end{table}
\end{itemize}

Par ailleurs, les op√©rateurs de comparaison, c'est √† dire
\begin{itemize}
  \item \textcolor{darkgreen}{est √©gale √†} (symbole \verb@==@, \textcolor{red}{attention aux deux symboles \texttt{=}})
  \item \textcolor{darkgreen}{est diff√©rent de} {symbole \verb@!=@})
  \item \textcolor{darkgreen}{est inf√©rieur √†} (symbole \verb@<@)
  \item \textcolor{darkgreen}{est sup√©rieur √†} (symbole \verb@>@)
  \item \textcolor{darkgreen}{est inf√©rieur ou √©gal √†} (symbole \verb@<=@)
  \item \textcolor{darkgreen}{est sup√©rieur ou √©gal √†} (symbole \verb@>=@)
\end{itemize}
renvoie des valeurs bool√©ennes. Ainsi, les instructions suivantes sont valides :
\begin{lstlisting}
bool est_plus_grand = 3 > 4; // est_plus_grand vaut false
bool est_plus_petit = 2 < 5; // est_plus_petit vaut true
bool flag = (1<5) && (5>2);  // flag vaut true
bool is_equal = (4==-4+7);   // is_equal vaut false
\end{lstlisting}

Si on veut afficher un bool√©en, on va, de la m√™me mani√®re que pour le programme "Hello World !" vu dans la section pr√©c√©dente,
utiliser un flux (de message) :
\begin{lstlisting}[caption=Exemple d'affichage basique d'un bool√©en]
std::cout << "est_plus_grand <-- " << est_plus_grand << std::endl
          << "est_plus_petit <-- " << est_plus_petit << std::endl;
\end{lstlisting}

A l'√©x√©cution, cette ligne d'instruction affichera
\begin{verbatim}
est_plus_grand <-- 0
est_plus_petit <-- 1
\end{verbatim}

ce qui ne semble pas correspondre √† la valeur de deux bool√©ens. En fait, c'est bien la valeur des deux bool√©ens\ldots 
Par convention, dans beaucoup de langages, dont le C++, la valeur enti√®re z√©ro correspond √† la valeur |false| et la valeur |1| (ou d'autres valeurs enti√®res non nulles) correspond √† la valeur |true|.

Les deux lignes suivantes sont parfaitement valides (mais non conseill√© pour des raisons de lisibilit√© du code) :
\begin{lstlisting}
bool fi = 0; // fi vaut |false|
bool fj = 1; // fj vaut |true|
\end{lstlisting}

Il est possible d'afficher sur l'√©cran une valeur "plus naturelle" pour les bool√©ens. Il faut pour cela utiliser la biblioth√®que standard |iomanip| qui contient entre autre une fonctionnalit√© permettant d'afficher |true| au |false| √† l'√©cran.

Ainsi, le programme suivant affichera bien des |true| et des |false| √† l'√©cran :
\begin{lstlisting}[caption=Exemple d'utilisation de std::boolalpha]
#include <iostream>
#include <iomanip>

int main()
{
  bool f1 = 0; // f1 est faux
  bool f2 = 1; // f2 est vrai
  std::cout << std::boolalpha << "f1 : " << f1 << std::endl;
  std::cout << "et f2 : " << f2 << std::endl;
  std::cout << std::noboolalpha << "f1 && f2 : " << f1 && f2 << std::endl;
  std::cout << "f1 || f2 : " << f1 || f2 << std::endl;
  return EXIT_SUCCESS;
}
\end{lstlisting}

L'instruction |std::boolalpha| dans le flux de message demande que les messages qui le suivent dans l'instruction et dans les instructions suivantes d'affichage devront afficher |true| ou |false| si ce sont des bool√©ens.

L'instruction |std::noboolalpha| dans le flux de message demande lui, au contraire, que les messages qui le suivent (dans l'instruction et ou les instructions d'affichage suivant) n'affichent plus les bool√©ens que comme une valeur enti√®re

Ainsi, l'ex√©cution de ce code affichera sur la console :
\begin{verbatim}
f1 : false
et f2 : true
f1 && f2 : 0
f1 || f2 : 1
\end{verbatim}

\subsubsection{Les entiers}

Il est possible en C++ (et en C) de d√©finir des variables de type entier (pouvant contenir des valeurs enti√®res).
Cependant, ces entiers ne peuvent contenir qu'une certaine √©tendue de valeurs, du fait que leur repr√©sentation dans la m√©moire de l'ordinateur ne prend que peu de place.

Le C++ d√©finit plusieurs types d'entiers, selon l'√©tendue des valeurs que l'on d√©sire mais aussi si on souhaite des entiers pouvant √™tre n√©gatifs ou non (sign√© ou non sign√© selon la terminologie C).

Voici un tableau r√©capitulant les divers types d'entiers propos√©s de base par le C/C++ :

\begin{tabular}{|c|c|c|}\hline
Type C & Commentaire & √©tendue \\ \hline \hline
|char| & {\small Entier repr√©sent√© sur 8 bits sign√© ou non sign√©} & $[0;255]$ ou $[-127;127]$ \\ \hline
|signed char| & {\small Entier sign√© repr√©sent√© sur 8 bits} & $[-127; 127]$ \\ \hline
|unsigned char| & {\small Entier non sign√© repr√©sent√© sur 8 bits} & $[0;255]$ \\ \hline
|short|             & \multirow{4}{*}{\small Entier sign√© repr√©sent√© sur 16 bits} & \multirow{4}{*}{$[-32767; 32767]$} \\ 
|short int| & & \\
|signed short| & & \\
|signed short int| & & \\ \hline
|unsigned short| & \multirow{2}{*}{\small Entier non sign√© repr√©sent√© sur 16 bits}& \multirow{2}{*}{$[0;65535]$} \\
|unsigned short int| & & \\ \hline
|int| & \multirow{3}{*}{\small Entier sign√© repr√©sent√© sur au moins 16 bits} &  Contient\\
|signed| & & \multirow{2}{*}{$[-32767;32767]$}\\
|signed int| & & \\ \hline
|unsigned| & \multirow{2}{*}{\small Entier non sign√© repr√©sent√© sur au moins 16 bits} & Contient \\
|unsigned int| & & $[0;65535]$ \\ \hline
|long|       & \multirow{4}{*}{\small Entier sign√© repr√©sent√© sur au moins 32 bits} &  \multirow{2}{*}{Contient}\\
|long int| & & \\
|signed long| & & \multirow{2}{*}{$[-2^{31}+1;2^{31}-1]$}\\
|signed long int| & & \\ \hline
|unsigned long| &\multirow{2}{*}{\small Entier non sign√© repr√©sent√© sur au moins 32 bits} & Contient \\ 
|unsigned long int| & & $[0;2^{32}-1]$\\ \hline
|long long|   & \multirow{4}{*}{\small Entier sign√© repr√©sent√© sur 64 bits} & \multirow{4}{*}{$[-2^{63}+1;2^{63}-1]$} \\
|long long int| & & \\
|signed long long| & & \\
|signed long long int| & & \\ \hline
|unsigned long long|     & \multirow{2}{*}{\small Entier non sign√© repr√©sent√© sur 64 bits} & \multirow{2}{*}{$[0;2^{64}-1]$} \\
|unsigned long long int| & & \\ \hline
\end{tabular}

Il est tr√®s important de s'assurer lorsqu'on programme que les valeurs prises par nos entiers ne d√©bordent pas, c'est √† dire n'est pas contenu dans l'intervalle des valeurs que peut prendre le type d'entier. On parle alors de d√©bordement de la repr√©sentation d'entier. D√©passer ces valeurs m√®nent √† des bogues tr√®s dur √† d√©tecter et pouvant avoir des cons√©quences dramatiques. L'exemple le plus tristement c√©l√®bre d'un tel bogue est l'explosion d'ariane V lors de son premier vol, √† cause d'une variable enti√®re ayant d√©pass√© les valeurs autoris√©es par son type. Pour illustrer le probl√®me, consid√©rons le code suivant :
\begin{lstlisting}[caption=D√©bordement d'entier]
short s = 32769;
signed char  t = 130;
std::cout << "s = " << s << " et t = " << int(t) << std::endl;
\end{lstlisting}

Si on ex√©cute le code correspondant, le programme affichera

\begin{verbatim}
s = -32767 et t = -126
\end{verbatim}

Ce ne sont pas les valeurs attendues !

L'explication vient du fait que le type |short| qui repr√©sente les entiers sign√©s sur deux octets 
ne peut prendre que des valeurs entre $-2^{15}+1 = -32767$ et $2^{15}-1 = 32767$ et que
le type |char| qui repr√©sente les entiers sign√©s sur un octet ne peut prendre que des valeurs entre
$1-2^{7}=-127$ et $2^{7}-1=+127$.

Un autre probl√®me des entiers en C/C++ est que certains entiers ont une taille et une √©tendue d√©pendant du syst√®me d'exploitation. En particuliers :
\begin{itemize}
  \item Le type |char| consid√©r√© comme sign√© sous Linux, Windows et Mac OS mais non sign√© sur Andro√Ød !
  \item Les entiers longs cod√©s sur trente-deux bits sous Windows mais sur soixante-quatre bits sur Linux ou Mac-OS
\end{itemize}

Heureusement, il existe un header |cstdint| qui permet de pouvoir sp√©cifier sans confusion possible le type d'entier qu'on souhaite manipuler :

\begin{lstlisting}[caption=D√©claration des entiers sans ambig√ºit√©]
#include <cstdint>

int main()
{
  std::uint8_t byte; // byte est un entier non sign√© (u) repr√©sent√© sur 8 bits (un octet)
  std::int8_t sbyte; // sbyte est un entier sign√© repr√©sent√© sur 8 bits (un octet)
  std::uin16_t ush;  // ush est un entier non sign√© repr√©sent√© sur 16  bits (deux octets)
  std::int16_t  sh;  // sh est un entier sign√© repr√©sent√© sur 16 bits (deux octets)
  std::uint32_t uent;// uent est un entier non sign√© repr√©sent√© sur 32 bits (quatre octets)
  std::int32_t ent;  // ent est un entier sign√© repr√©sent√© sur 32 bits (quatre octets)
  std::uint64_t ulg; // ulg est un entier non sign√© repr√©sent√© sur 64 bits (huit octets)
  std::int64_t   lg; //  lg est un entier sign√© repr√©sent√© sur 64 bits (huit octets)
}
\end{lstlisting}

Enfin, il est vivement conseill√© d'√©viter le plus possible l'emploi des entiers non sign√©s qui sont sources de nombreux bogues !
Prenons l'exemple suivant :

\begin{lstlisting}[caption=Exemple de bogue g√©n√©r√© par l'emploi d'un entier non sign√©]
std::uint32_t i,j;
for ( i = 1; i < 99; ++i )
{
  for ( j = i+1; j >= i-1; --j)
  {
     // On fait des calculs ici en utilisant i et j
  }
}
\end{lstlisting}

L'ex√©cution de ce code ne nous rendra jamais la main ! En effet, d√®s la premi√®re it√©ration sur |i|,
le test de continuation de la boucle sur |j| demande √† ce que |j| soit sup√©rieure ou √©gal √† z√©ro, 
ce qui est toujours le cas puisque |j| est de type non sign√© !

Ce probl√®me n'aurait pas eu lieu si on avait utilis√© des entiers sign√©s (ce qui est g√©n√©ralement suffisant).

De plus, si dans un code, un entier doit √™tre positif pour que l'algorithme reste dans son domaine d'application, 
il est pr√©f√©rable d'expliciter cette contrainte plut√¥t que de l'impliciter en prenant un entier non sign√© pour
repr√©senter l'entier (voir le chap√Ætre pr√©c√©dent).

Prenons l'exemple suivant :
\begin{lstlisting}[caption=Probl√®mes rencontr√©s avec les entiers non sign√©s]
// Recherche racine carr√©e d'un entier de la forme n¬≤ par dichotomie
std::uint32_t sqn = 3249; // n¬≤ = 57¬≤
std::uint32_t a = sqn;
std::uint32_t b = 0;
std::uint32_t c = (a+b)/2;
while (c*c-sqn != 0)// Tant que c n'est pas la racine carr√©e de a
{
  if (c*c-sqn<0)// Si c est plus petit que la racine carr√©e de a
  {
    b = c;
    c = (b+a)/2;
  }
  else
  {
    a = c;
    c = (b+a)/2;
  }
}
assert(c*c == sqn); // Post-condition
std::cout << "racine de " << sqn << " est egal a : " << c << std::endl;
\end{lstlisting}

Ce programme pose plusieurs probl√®me :
\begin{itemize}
  \item Il n'est pas clair que |sqn| doit √™tre un entier positif (l'algorithme pourrait chercher une racine complexe) si on ne fait pas attention √† son type (qui varie du type sign√© que d'une lettre !). Initialis√© |sqn| avec un nombre n√©gatif risque de poser de s√©rieux probl√®mes\ldots
  \item Plus grave, le programme ne marche pas et la boucle |while| (qu'on verra un peu plus loin) bouclera √† l'infini. En effet, le test |c*c-sqn<0| n'est jamais v√©rifi√© car |c| et |sqn| sont des entiers non sign√©s, et le r√©sultat en C++ (comme en C) de la diff√©rence de deux entiers non sign√©s est un entier non sign√© ! 
\end{itemize}

En rempla√ßant les entiers non sign√©s par des entiers sign√©s, on r√©soud les deux points mentionn√©s ci-dessus :
\begin{lstlisting}[caption=R√©solution probl√®me entiers non sign√©s avec des entiers sign√©s]
// Recherche racine carr√©e d'un entier de la forme n¬≤ par dichotomie
std::int32_t sqn = 3249; // n¬≤ = 57¬≤ (on peut remplacer)
assert(sqn>=0); // Pr√©-condition explicitant bien que sqn doit √™tre positive !
std::int32_t a = sqn;
std::int32_t b = 0;
std::int32_t c = (a+b)/2;
while (c*c-sqn != 0)// Tant que c n'est pas la racine carr√©e de a
{
  if (c*c-sqn<0)// Si c est plus petit que la racine carr√©e de a
  {
    b = c;
    c = (b+a)/2;
  }
  else
  {
    a = c;
    c = (b+a)/2;
  }
}
assert(c*c == sqn); // Post-condition
std::cout << "racine de " << sqn << " est egal a : " << c << std::endl;
\end{lstlisting}

Ainsi, on √©vitera √† la fois de nombreux bogues parfois difficiles √† trouver et une documentation plus claire pour
vous ou un autre lecteur √©ventuel du code.

En ce qui concerne l'affichage des entiers, comme on le voit sur l'exemple ci-dessus, il suffit de rajouter notre
entier dans le flot de sortie. Ainsi, dans l'exemple ci--dessus,
\begin{lstlisting}
std::cout << "racine de " << sqn << " est egal a : " << c << std::endl;
\end{lstlisting}
affichera bien
\begin{verbatim}
racine de 3249 est egal a : 57
\end{verbatim}

Si on veut formater la sortie des entiers, on peut utiliser (en incluant |iomanip|) les fonctions
|std::setw(n)| qui r√©serve |n| caract√®res pour le prochain affichage et |std::setfill(c)| qui compl√®tera
par le caract√®re |c| les |n| caract√®res r√©serv√©s. Ainsi :
\begin{lstlisting}
std::int32_t value1 = -32;
std::int32_t value2 =   3;

std::cout << "value1 = "  << value1 << std::endl;
std::cout << " et value2 = " << value2 << std::endl;

std::cout << "123456789ABCDEF" << std::endl;

std::cout << std::setw(15) << "value1 = " << std::setw(4) << value1 << std::endl;
std::cout << std::setw(15) << " et value2 = " << std::setw(4)  << std::setfill('0') << value2 << std::endl;
\end{lstlisting}

affichera

\begin{verbatim}
value1 = -32
 et value2 = 3
123456789ABCDEF
      value1 =  -32
   et value2 = 0003
\end{verbatim}

Les lettres "123456789ABCDEF" permettant de num√©roter les colonnes en hexad√©cimales de 1 √† F, cela permet de voir
qu'on affiche bien les entiers apr√®s la quinzi√®me colonne sur la console.

\subsubsection{Les r√©els}

Comme les entiers, les r√©els font partie du C++ natif (c'est √† dire qu'on n'a pas besoin d'inclure des biblioth√®ques).
Les r√©els sont repr√©sent√©s sur les ordinateurs en virgule flottante, c'est √† dire qu'un r√©el $x$ est repr√©sent√© sur
un ordinateur sous la forme
\[
x = \mbox{signe}\times\mbox{mantisse}\times2^{\mbox{exposant}}
\]
o√π
\begin{itemize}
  \item signe est un bit valant z√©ro pour les nombres positifs et un pour les nombres n√©gatifs;
  \item mantisse est un entier \textbf{non sign√©} repr√©sent√© sur $m$ bits ($n$ d√©pendant du type de r√©el choisit);
  \item exposant est un entier \textbf{sign√©} repr√©sent√© sur $e$ bits ($e$ d√©pendant du type de r√©el choisit).
\end{itemize}

Il existe trois  types de r√©els :
\begin{itemize}
  \item Les r√©els simple pr√©cision : Cod√©s sur trente-deux bits, leur mantisse est repr√©sent√© sur vingt-trois bits et leur exposant sur huit bits. La valeur d'un r√©el simple pr√©cision se note de chiffres avec la virgule symbolis√©e par un point,
  avec un |f| √† la fin du nombre. Par exemple : |float pi = 3.1415f;|
  \item Les r√©els double pr√©cision : Cod√©s sur soixante-quatre bits, leur mantisse est repr√©sent√© sur cinquante-deux bits
  et leur exposant sur onze bits. La valeur d'un r√©el double pr√©cision se note de chiffres avec la virgule symbolis√©e par un point. Par exemple : |double pi = 3.1415;|
  \item Les r√©els longs double pr√©cision : Cens√©s √™tre sur cent-ving-huit bits, ils sont sur la grande majorit√© des compilateurs repr√©sent√©s seulement sur quatre-vingt bits sur les processeurs de type Intel du fait qu'aucun processeur ne supporte  actuellement en natif des r√©els cent-vingt-huit bits. La valeur d'un r√©el long double pr√©cision se note de chiffres avec la virgule symbolis√©e par un point et avec le caract√®re |l| ou |L| √† la fin du nombre. Par exemple : |long double pi = 3.1415L|.
\end{itemize}

Il existe deux valeurs sp√©ciales pour les r√©els : NaN et la valeur infinity qu'on trouve dans la biblioth√®que |limits|.

La premi√®re valeur est une valeur indiquant que le nombre repr√©sent√© ne correspond pas √† la repr√©sentation d'un nombre r√©el (NaN est la contraction de "Not a Number"). Puisqu'obtenir un Nan peut √™tre un comportement anormale pour un code, le C++ offre deux "valeurs" diff√©rentes pour les Nans : |quiet_NaN| pour calculer sans broncher m√™me si le r√©sultat n'a pas de signification, et |signaling_NaN| qui si utilis√© lors d'un calcul signale une erreur.

La seconde valeur comme son nom l'indique repr√©sente une valeur infinie. 

La syntaxe pour ces valeurs est de la forme
\begin{lstlisting}
std::numeric_limits<Type>::quiet_NaN;
std::numeric_limits<Type>::signaling_NaN;
std::numeric_limits<Type>::infinity;
\end{lstlisting}
o√π |Type| est le type de r√©el pour lequel on veut une de ces trois valeurs (|float| ou |double|)

Les valeurs de type |NaN| ont la particularit√© de ne jamais √™tre √©gal. Ainsi,
\begin{lstlisting}
std::numeric_limits<float>::quiet_NaN == std::numeric_limits<float>;
\end{lstlisting}
renverra toujours |false|.

Pour tester si la valeur d'un r√©el est un NaN, il faut utiliser la fonction |isnan| pr√©sente dans la biblioth√®que |cmath|.
Par exemple :
\begin{lstlisting}
double x = 0./0.; 
std::cout << std::boolalpha << " x est un nan ? " << std::isnan(x) << std::endl;
\end{lstlisting}
affichera |true| sur la console.

Quant √† la valeur |infinity|, elle a la particularit√© d'√™tre toujours sup√©rieure √† n'importe quelle valeur r√©elle :
\begin{lstlisting}
#include <limits>

int main()
{
  float fx = std::numeric_limits<float>::max; // Prend la valeur maximale que peut prendre un r√©el simple pr√©cision
  float finf = std::numeric_limits<float>::infinity; // Prends la repr√©sentation de l'infini en r√©el simple pr√©cision
  std::cout << std::boolalpha << fx << " < infini" << " ?  : " << (fx < finf) << std::endl;
  return EXIT_SUCCESS;
}
\end{lstlisting}
affichera
\begin{verbatim}
3.40282e+38 < infini ? : true
\end{verbatim}


Puisque les r√©els sur les ordinateurs sont contenus dans un volume de m√©moire fixe, leur repr√©sentation est ent√¢ch√©e d'erreurs (pour repr√©senter $\pi$, il faudrait par exemple une m√©moire infinie\ldots)

Introduisons la notion d'erreur relative :
\begin{defn}
On appelle erreur relative d'un r√©el $x$, l'erreur faite sur la valeur de sa repr√©sentation $\tilde x$ dans la m√©moire de l'ordinateur :
\[
E_{r}(x,{\tilde x}) = \frac{\left\lvert x - {\tilde x}\right\rvert}{\left\lvert{\tilde x}\right\rvert}
\]
\end{defn}

Cette pr√©cision relative va d√©pendre du type de r√©el choisi :
\begin{itemize}
  \item Pour les r√©els simple pr√©cision, elle sera d'environ $10^{-6}$;
  \item Pour les r√©els double pr√©cision, elle sera d'environ $10^{-15}$;
  \item Pour les r√©els long double pr√©cision sur Intel/AMD, elle sera d'environ $10^{-18}$.
\end{itemize}

Bien s√ªr, le cumul d'erreur lors des calculs qui se rajouteront ou se compenserons fera que cette erreur sera plus ou moins grande par rapport √† l'erreur indiqu√©e ci-dessus. C'est tout l'art du num√©ricien de choisir, √† l'aide de ses outils math√©matiques, les bons algorithmes qui permettent d'avoir une solution proche de la solution exacte.

Pour employer les fonctions usuelles utili√©es en math√©matiques sur les r√©els, il faut utiliser la biblioth√®que |cmath|
qui contient la majorit√© des fonctions r√©elles usuelles. Par exemple :

\begin{lstlisting}
#include <cmath>
#include <iostream>

int main()
{
  float fpi = std::acos(-1.f);
  float fx  = std::cos(fpi/4.f);

  double pi = std::acos(1.);
  double x  = std::cos(pi/4.);
\end{lstlisting}

Pour voir les fonctions math√©matiques usuelles existantes dans la biblioth√®que |cmath|, allez voir le lien suivant :
\url{https://en.cppreference.com/w/cpp/numeric/math}

√Ä partir de C++ 17, il existe √©galement d'autres fonctions r√©elles plus sp√©cialis√©es que l'on peut trouver dans
la biblioth√®que |cmath|, comme des polyn√¥mes de Laguerre, Legendre, la fonction zeta de Riemann, etc\ldots

√Ä partir de C++ 20, il existe √©galement une biblioth√®que de constantes math√©matiques |numbers| qui d√©fini $\pi$, l'exponentielle, la racine de deux ou de trois et leurs inverses, le nombre d'or, la constante d'Euler $\gamma$, etc. (voir le lien  \url{https://en.cppreference.com/w/cpp/numeric/constants}).


\begin{lstlisting}[caption=Exemple d'utilisation des constantes en C++ 20,mathescape=true]
#include <cmath>
#include <numbers>
#include <iostream>

int main()
{
  float $\pi$_f = std::numbers::pi_v<float>;
  double $\pi$   = std::numbers::pi;
  long double $\pi$_lf = std::numbers::pi_v<long double>;
  double $\pi^{-1}$ = std::numbers::inv_pi;

  std::cout << "$\pi$_f  = " << std::setprecision(std::numeric_limits<float>::digits10+1) << $\pi$_f << std:endl;
  std::cout << "$\pi$    = " << std::setprecision(std::numeric_limits<double>::digits10+1) << $\pi$ << std:endl;
  std::cout << "$\pi$_lf = " << std::setprecision(std::numeric_limits<long double>::digits10+1) << $\pi$_lf << std:endl;
  std::cout << "$\pi^{-1}$  = " << std::setprecision(std::numeric_limits<double>::digits10+1) << $\pi^{-1}$ << std::endl;

  return EXIT_SUCCESS;
}
\end{lstlisting}

Par d√©faut, la valeur $\pi$ est en double pr√©cision, mais on peut utiliser |std::numbers::pi_v<Type>| pour avoir une valeur de $\pi$ en simple pr√©cision ou en double long.

Notez l'utilisation de |std::numeric_limits<double>::digits10| avec |std::setprecision| pour afficher les chiffres
significatifs de $\pi$ selon le type de r√©el employ√©.

\subsubsection{Les complexes}

Les nombres complexes ne sont pas des types natifs du C++, mais la biblioth√®que standard (d√©fini par le standard ISO) propose des types complexes.

On peut donc trouver la gestion des complexes dans la biblioth√®que |complex|, qui permet de d√©finir plusieurs types de complexes :
\begin{lstlisting}[caption=Exemple de d√©claration et de d√©finition de nombres complexes]
#include <complex>

int main()
{
    ...
    std::complex<float> fcomplex;
    std::complex<double> i(0.,1.);
    std::complex<std::int32_t>   gauss(2,-3); // 2 -3i dans Z + i Z
    ...
}
\end{lstlisting}

Le type donn√© entre les chevrons $<$ et $>$ est le type de scalaire qui repr√©sente la partie r√©elle et la partie imaginaire du complexe. Ainsi, dans le code ci--dessus, |fcomplex| est un complexe dont la partie r√©elle et la partie imaginaire sont de type |float|, |i| quant-√† lui aura sa partie r√©elle et sa partie complexe repr√©sent√©es par 
des r√©els double pr√©cision |double|, tandis que |gauss| aura sa partie r√©elle et sa partie imaginaire repr√©sent√©es
par des entiers de type |std::int32_t|.

Remarquons aussi que l'initialisation (qu'on verra un peu plus bas) des nombres complexes se fait g√©n√©ralement en donnant la partie r√©elle et la partie imaginaire entre parenth√®ses lors de la d√©claration.

N√©anmoins, si on veut une √©criture plus naturelle des nombres complexes dans le code, on le peut depuis le C++ 2014 de
la mani√®re suivante :

\begin{lstlisting}[caption=Exemple de d√©claration des complexes √† l'aide de litt√©raux]
#include <complex>
#include <iostream>

int main()
{
    using namespace std::complex_literals;
    std::complex<double> c = 1.0 + 1i;
    std::cout << "abs" << c << " = " << std::abs(c) << '\n';
    std::complex<float> z = 3.0f + 4.0if;
    std::cout << "abs" << z << " = " << std::abs(z) << '\n';
}
\end{lstlisting}

La ligne |using namespace std::complex_literals;| est essentielle pour pouvoir ensuite √©crire les complexes d'une mani√®re naturelle. Notons enfin que pour cette √©criture naturelle ne fonctionne que si la partie r√©elle et la partie imaginaire d'un complexe sont r√©elles : simple (suffixe |if|), double (suffixe |i|) ou longue double (suffixe |ilf|).

Notons que la fonction |std::abs| dans l'exemple ci-dessus calcul la norme du complexe.

Il est possible √©galement d'avoir l'argument du complexe ou bien encore sa norme au carr√© ( ce qui √©vite de calculer une racine carr√©e). De plus, les fonctions usuelles sont d√©finies dans |complex| et il est possible de calculer des exponentielles, des racines, des sinus ou encore des cosinus complexes (en prenant la construction de Poincarr√© pour ces fonctions). 

\textcolor{red}{Attention} : Contrairement √† ce que l'on peut penser, le code ci--dessous :
\begin{lstlisting}
std::complex<double> c = 1. + 1i;
std::cout << c.norm() << std::endl;
\end{lstlisting}

n'affiche pas la norme de |c| mais le carr√© de sa norme (sic).

\subsection{Les cha√Ænes de caract√®re}

Une cha√Æne de caract√®re basiquement est un tableau de "caract√®res", o√π les caract√®res sont des chiffres, des lettres, des symboles.

Ces chiffres, lettres, symboles peuvent √™tre repr√©sent√©s de diverses mani√®res en m√©moire selon l'encodage choisi. On distingue les encodages suivant :
\begin{itemize}
  \item ASCII (\textbf{A}merican \textbf{S}tandard \textbf{C}ode for \textbf{I}nformation \textbf{E}change) : 
  C'est un encodage des caract√®res paru aux alentours de 1960 qui permettait de transmettre des suites de caract√®res
  entre diff√©rents appareils √©lectroniques. Cod√© sur sept bits (plus un bit de contr√¥le), cet encodage est pr√©vu que
  pour g√©rer les caract√®res anglosaxons. Rien n'est donc pr√©vu dans la norme pour g√©rer les accents fran√ßais, ou les lettres allemandes, le cyrillic, le grecque, etc... C'est n√©anmoins l'encodage le plus universel actuellement, accept√© par tous les syst√®mes et machines actuelles.
  \item UTF8 (\textbf{U}niversal character set \textbf{T}ransformation \textbf{F}ormat -- \textbf{8} bits) :
  est un encodage des caract√®res con√ßu pour coder l'ensemble des caract√®res connus propos√© par l'ISO (\textbf{I}nternational \textbf{S}tandardization \textbf{O}rganization). Cet encodage reste totalement compatible avec le codage ASCII pour ce qui concerne les caract√®res anglo-saxons. Cet encodage a la particularit√© que chaque caract√®re n'est pas encod√© sur un nombre fixe d'octet mais encod√© sur un √† quatre octets !
  \item UTF16 (\textbf{U}niversal character set \textbf{T}ransformation \textbf{F}ormat -- \textbf{16} bits) : Proche de l'UTF-8, les caract√®res sont encod√©s cette fois ci sur deux ou quatre octets. Les caract√®res occidentaux sont tous encod√©s sur deux octets ce qui fait que l'UTF16 est compatible en occident avec l'encode UCS-2 (dont les caract√®res sont encod√©s avec une taille fixe de deux octets);
  \item UTF32 (\textbf{U}niversal character set \textbf{T}ransformation \textbf{F}ormat -- \textbf{32} bits) : Proche de l'UTF-8, les caract√®res ont d√©sormais une taille fixe de quatre octets par caract√®re. 
\end{itemize}

Si il est possible de d√©finir un caract√®re par un de ces quatre encodages, le C++, mise √† part l'encodage ASCII, ne propose que peu de chose pour g√©rer efficacement les autres encodages, que ce soit pour les caract√®res que pour les cha√Ænes de caract√®res.

Plusieurs types de cha√Ænes de caract√®res sont propos√©s en C++ : les cha√Ænes de caract√®res "basiques" et les |std::string|
qui offrent des services permettant de g√©rer plus facilement les cha√Ænes de caract√®res que les cha√Ænes "basiques".

\subsection{Les caract√®res}

La valeur d'un caract√®re est encadr√©e par deux simples quotes \verb@'@. 

Puisqu'un caract√®re peut-√™tre cod√© en ASCII (un octet), en UTF8 (un √† quatre octets), en UTF16 (deux ou quatre octets), etc., il faut parfois utiliser un type sp√©cial pour d√©clar√© le type d'un caract√®re :
\begin{itemize}
  \item Pour l'ASCII : Le type |char| suffit et on peut l'afficher normalement avec |std::cout|;
  \item Pour l'UTF8  : le type |char| est utilis√©, mais ne permet pas d'obtenir les caract√®res cod√©s sur plus de un octet ! On affiche un caract√®re UTF8 avec |std::cout|;
  \item Pour l'UTF16 : le type |wchar_t| est utilis√© pour afficher toutes les lettres occidentales possibles √† l'aide de |std::wcout| (Wide Cout). On peut √©galement stocker un caract√®re UTF16 dans le type |char16_t|, mais il n'est plus possible dans ce cas de l'afficher (du moins, rien n'est propos√© en C++ pour cela)
  \item Pour l'UTF32 : On peut stocker le caract√®re dans un |char32_t| mais rien n'est propos√© dans le C++ pour l'afficher (du moins √† ma connaissance).
\end{itemize}

Notons que |wchar_t|, |char16_t| et |char32_t| sont des types basiques √† partir de C++ 11.

Pour d√©finir l'encode du caract√®re, ormis pour l'ASCII o√π deux simples quotes suffisent, on rajoute un pr√©fixe
devant le premier simple quote, √† savoir
\begin{itemize}
  \item Le pr√©fixe 'u8' pour un encodage utf8
  \item Le pr√©fixe 'L'  pour un encodage utf16
  \item Le pr√©fixe 'u'  pour un encodage utf32
\end{itemize}

\begin{lstlisting}
char ascii = 'p';
char utf8  = u8'p';
// Remarquer que utf8 = u8'√©' va g√©n√©rer une erreur car le caract√®re '√©' est cod√© en UTF 8 sur plus de un octet !
wchar_t utf16 = L'√©';
// On aurait pu aussi √©crire char16_t utf16 = L'√©' mais on n'aurait pas pu l'afficher dans ce cas.
char32_t utf32 = u'√©'; // Mais comment l'afficher ensuite ????
\end{lstlisting}

Enfin, remarquons, et ce sera le m√™me probl√®me pour les cha√Ænes de caract√®re, que l'affichage d'un caract√®re autre
qu'un caract√®re "ASCII" peut poser probl√®me car rien ne vous assure que l'encodage des caract√®res attendus par votre console est compatible avec l'encodage choisi dans votre code (et c'est ce qui arrive 99.99\% du temps !).

Il existe √©galement des caract√®res de contr√¥le. Les plus courants sont :
\begin{itemize}
  \item Le retour √† la ligne |'\n'| qui permet d'aller √† la ligne suivante
  \item La tabulation |'\t'| qui permet de tabuler et d'aligner l'affichage
  \item Le retour en d√©but de ligne |'\r'| qui permet de revenir √† la premi√®re colonne de la ligne courante
\end{itemize}

\subsubsection{Les cha√Ænes de caract√®res basiques}

La valeur d'une cha√Æne de caract√®re est encadr√©e par deux doubles quotes \verb@"@. Par exemple :
\begin{lstlisting}
"Ceci est une cha√Æne de caract√®re !"
\end{lstlisting}

Notons qu'il est interdit, normalement, de sauter une ligne dans la d√©finition d'une cha√Æne de caract√®re,
car le saut √† la ligne signifiera pour le C++ qu'on change d'instruction. Cela r√©sultera alors par une erreur
de compilation.

Notons que contrairement aux caract√®res, les cha√Ænes de caract√®res acceptent les accents et autres symboles.
Elles utilisent pour cela les caract√®res √©tendus (cod√©s sur seize bits).

Si on veut afficher un caract√®re double quote dans une cha√Æne de caract√®re, il faut alors utiliser |\"|.
Par exemple (pour citer Desproges : "Dictionnaire superflu √† l'usage de l'√©lite et des bien nantis.") :
\begin{lstlisting}
"\"Alea Jacta Est\" : Ils sont bavards √† la gare de l'Est !" 
\end{lstlisting}

Pour avoir un encodage sp√©cifique de la cha√Æne de caract√®re, on rajoute les m√™mes pr√©fixes que pour un caract√®re.
Ainsi :
\begin{lstlisting}
u8"œÄ est un caract√®re tr√®s sp√©cial !"
\end{lstlisting}
va coder la cha√Æne en UTF8.

Une cha√Æne de caract√®re √©tant consid√©r√© comme un tableau de caract√®res, on utilise comme type basique pour les cha√Ænes de caract√®re le type |char []| qui n'est autre que la d√©claration d'un tableau statique de caract√®re (les tableaux statiques sont pr√©sent√©s plus loin). Ainsi, on peut stocker notre cha√Æne de caract√®re UTF 8 comme :
\begin{lstlisting}[mathescape=true]
char texte[] = u8"$\pi$ est un caract√®re tr√®s sp√©cial !";
\end{lstlisting}

Enfin, depuis C++ 11 qui s'est beaucoup inspir√© de Python, il est possible de d√©finir des cha√Ænes de caract√®re "brutes",
c'est √† dire des cha√Ænes de caract√®res o√π le C++ n'interpr√©tera pas les caract√®res de contr√¥les, en particuliers le retour √† la ligne ou les doubles quotes. Pour former de telles cha√Ænes de caract√®res, il faut rajouter le pr√©fixe |R| √† gauche du premier double quote, puis √† l'int√©rieur des doubles quotes, on d√©finit un d√©limiteur constitu√© de une ou plusieurs caract√®res suivi d'une parenth√®se ouvrante. On √©crit ensuite ce que l'on veut jusqu'√† ce qu'on √©crit une parenth√®se fermante suivie du m√™me d√©limiteur que le d√©but de la cha√Æne. On fermet ensuite les doubles quotes pour former la cha√Æne de caract√®re. Par exemple :
\begin{lstlisting}
char raw_texte[] = 
R"DEL(Si nous prenons encadrons une formule par une ( et  par une ) ("parenth√®se") alors :
     1. Cela permet de s'assurer de l'ordre des op√©rations;
     2. D'√™tre plus clair dans le code;
     3. Modifier l'ordre des op√©rations
)DEL";
\end{lstlisting}

nous permet de d√©finir un texte multi-ligne en UTF 8 qu'on peut ensuite afficher sur console qui affichera :

\begin{inverseverbatim}
Si nous prenons encadrons une formule par une ( et  par une ) ("parenth√®se") alors :
     1. Cela permet de s'assurer de l'ordre des op√©rations;
     2. D'√™tre plus clair dans le code;
     3. Modifier l'ordre des op√©rations
\end{inverseverbatim}

Remarquer que les retours chariot sont bien pris en compte lors de l'affichage. Pour ceux d'entre vous rompus au langage C, vous serez peut-√™tre surpris que je n'ai pas employ√© un pointeur sur un tableau de caract√®re mais un tableau statique
de caract√®re. En fait, √† partir de C++ 11, il n'est plus possible de d√©finir une cha√Æne de caract√®re constant via un pointeur sur cette cha√Æne.

\subsubsection{Les cha√Ænes de caract√®res std::string}

Si les cha√Ænes basiques du C++ sont utiles pour afficher des messages √† l'√©cran, elles ne sont gu√®res pratiques √† manipuler. Le C++ poss√®de dans sa biblioth√®que standard un type cha√Æne de caract√®re bien plus facile √† manipuler : |std::string|. Pour l'utiliser, il faut inclure la biblioth√®que |string| puis d√©clarer une variable comme √©tant de type |std::string|.

Ainsi :
\begin{lstlisting}[caption=D√©claration d'une std::string]
std::string une_cha√Æne;
std::string une_deuxi√®me_cha√Æne = "Ceci est une cha√Æne de caract√®re";
\end{lstlisting}

Si les deux lignes ci--dessus sont valides, la seconde ligne n'est pas optimale et effectue des copies m√©moires inutiles et relativement gourmandes en ressources. En effet, la cha√Æne de caract√®re √† droite du signe |=| est une cha√Æne de caract√®re basique, qui doit √™tre convertie en cha√Æne de caract√®re |std::string|. 
Pour √©viter cette copie, √† partir de C++ 14, il est possible
de directement d√©clarer la cha√Æne de caract√®re √† droite du signe √©gal comme √©tant une |std::string|. Pour cela, il faut utiliser le suffixe litt√©ral |s| apr√®s le dernier double quote apr√®s avoir utilis√© un |using namespace| comme dans le code ci--dessous :
\begin{lstlisting}[caption=Utilisation d'un lit√©ral pour d√©finir un std::string]
using namespace std::string_literals;// Indispensable pour utiliser le suffixe s

int main()
{
  std::string une_troisi√®me_cha√Æne = "Ceci est une std::string"s; 
}
\end{lstlisting}

\textcolor{red}{\bf Attention} :
En ce qui concerne l'encodage UTF 8, il √©tait facile avant le C++ 20 d'afficher et stocker de l'UTF 8.
Depuis le C++ 20, la cha√Æne de caract√®re utilisant l'UTF 8 n'utilise plus le type |char| mais le type
|char8_t| ce qui a pour cons√©quence qu'on ne peut plus ni stocker une cha√Æne de caract√®re en UTF 8, ni l'afficher
avec |std::cout| ! Bref, il vaut mieux √©viter si possible de manipuler explicitement des cha√Ænes de caract√®res avec
un encodage sp√©cifique !

\textcolor{blue}{Remarque} : Si il est pr√©f√©rable actuellement d'√©viter en C++ de manipuler des cha√Ænes de caract√®res
explicitement en u8, il est tout √† fait possible d'√©crire des cha√Ænes de caract√®res avec des caract√®res appartenent √†
l'unicode en UTF 8, qui seront pris comme des caract√®res ordinaires lors de la manipulation, mais pas √† l'affichage.
En outre, √©viter de manipuler des cha√Ænes de caract√®res en unicode ne veut pas dire que de d√©clarer des variables en unicode pose probl√®me...

Les |std::string| on l'avantage de pouvoir se manier facilement pour les traiter efficacement :
\begin{lstlisting}[caption=Exemple de manipulation de std::string]
std::string    nom   = "Dupont"s;
std::string pr√©nom   = "Albert"s;
std::string    √¢ge   = std::to_string(20);
std::string identit√© = nom + " "s + pr√©nom + " : √¢ge "s << √¢ge << " ans.\n"s;
std::cout << identit√©;
\end{lstlisting}

Ici, on d√©finit un nom et un pr√©nom en |std::string|. On convertit ensuite un entier (ici 20) en cha√Æne de caract√®re
√† l'aide d'une fonction |std::to_string| puis on concat√®ne les diverses variables pour cr√©er une cha√Æne de caract√®re
donnant l'identit√© de la personne.

On peut √©galement tester si on trouve une sous-cha√Æne dans une cha√Æne (√† partir du d√©but de la cha√Æne ou √† partir d'une position sp√©cifi√©e comme dans l'exemple ci--dessous) :
\begin{lstlisting}[caption=Exemple de recherche d'une sous-cha√Æne dans une cha√Æne]
std::string grosse_cha√Æne = "Ceci est un essai int√©ressant. Peut-on trouver une sous-cha√Æne dans une grosse cha√Æne ?";
// On cherche une premi√®re occurence de cha√Æne dans la grosse_cha√Æne :
std::size_t pos = grosse_cha√Æne.find("cha√Æne"s);
if (pos != std::string::npos)
    std::cout << "J'ai trouv√© une premi√®re occurence de cha√Æne √† la position : " << pos << std::endl;
// Puis on recommence une nouvelle recherche apr√®s la premi√®re position de cha√Æne :
pos = grosse_cha√Æne.find("cha√Æne"s, pos+1);
if (pos != std::string::npos)
    std::cout << "J'ai trouv√© une seconde occurence de cha√Æne √† la position : " << pos << std::endl;
\end{lstlisting}
dont la sortie obtenue est :
\begin{inverseverbatim}
J'ai trouv√© une premi√®re occurence de cha√Æne √† la position : 57
J'ai trouv√© une seconde occurence de cha√Æne √† la position : 81
\end{inverseverbatim}

Enfin, on peut tester la longueur d'une cha√Æne (en octet) : 
\begin{lstlisting}
std::cout << "Longueur de cha√Æne : " << "cha√Æne"s.length() << std::endl;
\end{lstlisting}
qui nous donne en sortie:
\begin{inverseverbatim}
Longueur de cha√Æne : 7
\end{inverseverbatim}

Remarquons que le r√©sultat affich√© n'est pas celui \textsl{a priori} attendu, puisque "cha√Æne" ne contient que six
caract√®re. Cela vient du fait que le caract√®re $√Æ$ est stock√© sur deux octets en UTF 8 (qui est ici implicite).

Cela nous permet √©galement de conclure qu'il est pr√©f√©rable d'√©viter de manipuler, hors affichage (et encore faut-il s'assurer que notre console est capable d'afficher de l'UTF 8, ce qui n'est pas toujours le cas, surtout sous Windows !), des cha√Ænes de caract√®res qui poss√®dent autre chose que de l'ASCII sous peine d'avoir de nombreuses surprises

\subsection{D√©clarations automatiques implicites et explicites}



Le compilateur peut √©galement d√©duire le type d'une variable lorsque cela est possible. On utilise pour cela le mot clef
\texttt{auto}. On parle alors de \textsl{d√©claration implicite} d'une variable :

\begin{lstlisting}[caption=Exemple d'utilisation d'une d√©claration implicite]
void main()
{
    auto i = 1; // OK, i est un entier
    auto x = 3.14; // OK, x est un double
    auto y = 2.5f; // OK, y est un float
    auto z = x + y; // z est un double par promotion de y en double pour le calcul
    auto w = x + i; // w est un double par promotion de i en double pour le calcul

    auto j; // Erreur de compilation ! Le compilateur ne peut pas d√©duire le type de j
}
\end{lstlisting}

Nous verrons dans le cours de nombreuses utilisations des d√©clarations implicites, en particuliers lors du cours sur les templates, o√π ce type de d√©claration permet de simplifier fortement le code !

Il existe √©galement un mot clef, \texttt{decltype}, permettant au compilateur de d√©duire \textsl{explicitement} un type de variable √† partir d'une expression. Par exemple :

\begin{lstlisting}[caption=d√©duction explicite de type]
void main()
{
    int i = 1;
    decltype(i) j; // j est du m√™me type que i et non initialis√©
    double x = 3.14;
    decltype(x+i) y; // y est du m√™me type que x+i, c'est √† dire un double (remarquons que y est non initialis√©)

    decltype(i/j+1) k  = 1+i/j; // k est un entier.
}
\end{lstlisting}

L√† encore, l'emploi de ce mot clef est particuli√®rement utile lors de la programmation √† l'aide des templates.

Enfin, si en C ou C++ 98, il n'existait qu'une fa√ßon de faire un alias de type en utilisant le mot clef |typedef|,

\begin{lstlisting}
typedef double reel; // Alias de type √† la fa√ßon C

reel x; // x est en fait un double
\end{lstlisting}

il existe en C++ 11 et sup√©rieur une deuxi√®me fa√ßon utilisant le mot clef |using| et permettant une syntaxe plus claire
et plus souple !

\begin{lstlisting}
using reel = double;

reel x; // x est en fait un double
\end{lstlisting}

De plus, lors du chap√Ætre sur les templates, nous verrons que c'est le seul moyen de faire un alias de type sur un template !

\subsection{Initialisation des variables}

L'initialisation des variables en C++ peut s'√©crire de trois fa√ßons :

\begin{itemize}
    \item √Ä la C
    \begin{lstlisting}
    int i = 0, j = 1, k = -2; // D√©claration avec initialisation
    double x; // D√©claration uniquement
    x = 3.1415; // Puis initialisation
    \end{lstlisting}
    \item Initialisation par construction : √† l'aide d'une parenth√®se (C++ 98)
    \begin{lstlisting}
    int i(0), j(1), k(-2);
    double x(3.1415);
    int l = int(x+0.5); // Conversion d'un r√©el en entier
    std::vector<double> tableau(10,3.);// Cr√©er un tableau de 10 r√©els rempli de la valeurs trois
    \end{lstlisting}
    Remarquer que la derni√®re initialisation, celle cr√©ant un tableau, est impossible √†
    faire en utilisant l'√©criture du C, puisque cette initialisation demande deux param√®tres
    (un entier et un r√©el).
    \item Initialisation par liste d'initialisation : √† l'aide d'une accolade
    \begin{lstlisting}
    int i{0}, j{1}, k{-2};
    \end{lstlisting}
    √Ä partir de C++ 20, les accolades permettent l'initialisation d'une structure en nommant les champs qu'on veut initialiser
    (dans l'ordre de d√©claration sinon on aura une erreur), √† l'instar de la norme 99 du langage C :
    \begin{lstlisting}
    /* D√©finit le type Client : */
    struct client
    {
      int age;
      int poids
      int taille;
    };
    client john{
        .age = 35,
        .taille = 190,
    };// Le poids est mis par d√©faut √† z√©ro car non sp√©cifi√©.
    \end{lstlisting}
    Si elle s'av√®re pratique, l'usage des accolades parfois peut √™tre aussi source de confusion :
    \begin{lstlisting}
    std::vector<double> tableau(10,3.);// Cr√©er un tableau de 10 r√©els rempli de trois
    std::vector<double> tableau{10,3.};// Cr√©er un tableau de 2 r√©els : [10,3] !
    \end{lstlisting}
    Il faut donc utiliser cette derni√®re possibilit√© avec pr√©caution !
\end{itemize}

\textbf{√Ä partir de C++ 11} :

Si l'√©criture octale, d√©cimale ou hexad√©cimale est autoris√©e depuis le C, il n'√©tait pas possible d'√©crire un nombre en binaire.
Depuis C++ 11, cet oubli est r√©par√© et il est  possible d'√©crire un nombre en binaire √† l'aide du pr√©fixe |0b| :

\begin{lstlisting}[caption=Ecriture binaire\, octale\, d√©cimale et hexad√©cimale]
    int a = 037;        // Ecriture octale (pr√©fixe 0), a vaut 31 en d√©cimal (8*3 + 7)
    int b = 103;        // Ecriture d√©cimale 
    int c = 0xF0;       // Ecriture hexad√©cimale (pr√©fixe 0x) : c vaut 240 (15*16 + 0)
    int d = 0b01100110; // Ecriture binaire (pr√©fixe 0b): d vaut 102 (2 + 4 + 32 + 64)
\end{lstlisting}

\textbf{√Ä partir de C++ 14} :

La lecture de grand nombres, particuli√®rement en binaire, peut √™tre p√©nible lors de la lecture ou l'√©criture d'un code et
√™tre sources d'erreurs difficiles √† d√©tecter !

Consid√©rons le code suivant :

\begin{lstlisting}
  double e     = 2.718281828459045;
  long long  l = 1345652343LL;
  long long bl = 0b11011011110110111011110111011101LL;
\end{lstlisting}

Si il est difficile de lire la valeur de |e| ou |l|, il est encore plus difficile de lire la valeur en binaire de |bl| !

C++ 14 introduit le caract√®re simple quote (|'|) comme s√©p√©rateur de chiffres. Ainsi, en C++ 14 ou sup√©rieur,
il est possible de re√©crire le code pr√©c√©dent comme suit :

\begin{lstlisting}[caption=Ecriture avec s√©parateur de chiffre (C++ 14)]
  double     e = 2.718'281'828'459'045;
  long long  l = 1'345'652'343LL;
  long long bl = 0b1101'1011'1101'1011'1011'1101'1101'1101LL;
\end{lstlisting}

ce qui permet une lecture plus ais√©e des valeurs de |e|, |l| et |bl| !

Remarquons que le s√©parateur peut √™tre mis n'importe o√π entre deux chiffres dans le nombre. Ainsi, il est possible (mais sans int√©r√™t) d'√©crire un nombre sous la forme |3'42'3564'3'2LL| ce qui ne facilite pas la lecture (qui est pourtant le but de ce rajout au C++)

\subsection{Le qualificateur const}

Consid√©rons une variable telle que $\pi$. De toute √©vidence, cette variable sera fix√©e √† une certaine valeur (qui sera une bonne approximation de la valeur exacte !) tout le long
de l'ex√©cution du programme.

En effet, imaginons le programme suivant :
\begin{lstlisting}[mathescape=true]
double $\pi$ = 3.141592653589793;
...
// Bien plus loin dans le code
$\pi$ = -1.;
...
// Et encore bien plus loin
int rayon = 3;
// Calcul de la circonf√©rence du cercle
double circonf√©rence = 2*$\pi$*rayon;
\end{lstlisting}

Manifestement, le r√©sultat √† la fin sera faux ! Pourquoi avoir chang√© $\pi$, me direz-vous ?
H√© bien, cela peut arriver pour moultes raisons ! On a voulu changer la valeur d'une autre
variable et on a malencontreusement pris $\pi$ √† la place (√† cause d'une compl√©tion
malheureuse, par exemple), ou encore, dans un contexte de programmation embarqu√©e,
on voulait reutiliser une variable d√©j√† existante pour limiter la m√©moire prise par le programme, etc\ldots Bref, cela arrive bien plus fr√©quemment qu'on pourrait se l'imaginer.

Puisque de toute √©vidence, la valeur de $\pi$ n'est pas destin√©e √† √™tre modifi√©e, il est n√©cessaire de la prot√©ger contre toute modification √©ventuelle apr√®s son initialisation.
C'est le r√¥le du mot clef |const|.

C'est un qualificateur, car il ne modifie pas le type fondamental de la variable. Simplement il lui rajoute une propri√©t√© suppl√©mentaire : celle d'√™tre immuable.
Il se rajoute avant ou apr√®s le type de la variable.

Par exemple :
\begin{lstlisting}[mathescape=true]
const double $\pi$ = 3.141592653589793;
double const e = 2.718281828459045;
\end{lstlisting}

Tenter de modifier la valeur d'une variable constante d√©clenche une erreur de compilation.
C'est bien ce que l'on veut !

\subsection{Pointeurs et adresse m√©moire}

\subsubsection{Les pointeurs natifs}

Nous avons vu, sans le dire, un pointeur lorsque nous avons parl√© des cha√Ænes de caract√®res : |char *|.
Un pointeur n'est rien d'autre qu'une adresse m√©moire, c'est √† dire un nombre donnant un emplacement dans la m√©moire. Il peut bien entendu √™tre initialis√© √† n'importe quel nombre, mais son int√©r√™t est de prendre une valeur correspondant √† l'emplacement m√©moire d'une variable ! Remarquons qu'un pointeur ne permet pas directement de stocker une valeur, il ne fait que stocker l'adresse o√π se trouve cette valeur (qui aura donc d√©j√† √©t√© stock√©e dans un espace r√©serv√© en m√©moire).

Une pointeur se d√©clare avec un type, et une |*| accol√©e au nom de la variable. Attention, dans le cas d'une multi-d√©claration, chaque variable de type pointeur doit avoir une |*| accol√©e √† son nom. Ainsi :
\begin{lstlisting}[caption=D√©claration de pointeurs]
int *pt_1, *pt2; // Pointeur sur des entiers
double * pt_3, *pt_4; // Pointeur sur des doubles
char *pt_5, ch; // Attention ch est un char, pas un pointeur !
\end{lstlisting}

Pour trouver l'adresse d'une variable ( son emplacement m√©moire ), il suffit d'utiliser le symbole \verb@&\verb@ :

\begin{lstlisting}
int une_valeur = 3;
int *pt_valeur = &une_valeur; // Adresse de une_valeur
\end{lstlisting}

Il est √©galement possible de faire de l'arithm√©tique avec les pointeurs. Dans ce cas, le pointeur tient compte du type de donn√©e sur lequel il pointe. Par exemple, si un pointeur |pt_tab| pointe  sur le premier √©l√©ment d'un tableau |tab| de |double|, alors |pt_tab+1| pointera sur le deuxi√®me, et plus g√©n√©ralement |pt_tab+i| pointera sur le $(i+1)^{e}$ √©l√©ment du tableau |tab| qui correspond √†
|tab[i]| (n'oublions pas que les indices commencent √† z√©ro en C/C++, voir plus loin pour les tableaux).

Pour acc√©der √† une valeur se trouvant √† l'adresse stock√©e dans le pointeur, il suffit d'utiliser l'op√©rateur de d√©f√©rencement |*| :
\begin{lstlisting}[caption=Exemple d'utilisation du d√©f√©rencement]
int une_valeur = 3;
int *pt_valeur = &une_valeur; // On pointe sur une_valeur
*pt_valeur += 1; // On incr√©mente une_valeur point√©e par pt_valeur
\end{lstlisting}

Les pointeurs sont tr√®s utiles pour divers contextes, en particuliers pour parcourir ou stocker des tableaux dynamiquement (voir plus loin).

Il est possible que deux pointeurs pointent sur la m√™me variable. Si on utilise ces deux pointeurs pour lire ou modifier la valeur point√©e, cela ne pose pas de soucis en s√©quentiel. Par contre, si on veut utiliser les deux pointeurs pour lib√©rer l'espace m√©moire occup√©e par la valeur (on verra comment faire plus loin), cela peut √™tre probl√©matique, car on ne peut pas lib√©rer deux fois la m√™me zone m√©moire sans obtenir une erreur fatale durant l'ex√©cution du programme.

Enfin, il existe un pointeur sp√©cial, le pointeur nul, qui ne pointe sur aucune valeur. En C++, ce pointeur est d√©fini dans la biblioth√®que |<memory>| et se nomme |std::ptr_null|. Pour ceux qui ont fait du C, attention, ce n'est pas du tout l'√©quivalent de |NULL| en C (qui existe √©galement pour la compatibilit√© avec le C) !

Pour les pointeurs, attention √† l'usage du qualificateur |const| avec les pointeurs :
\begin{itemize}
  \item Plac√© \textbf{avant le symbole} \verb@*@ d√©signant le pointeur, il signifie que le pointeur pointe sur une valeur
        qu'il consid√®re comme constant (m√™me si elle ne l'est pas)
  \item Plac√© \textbf{apr√®s le symbole} \verb@*@ d√©signant le pointeur, il signifie que le pointeur lui-m√™me est constant,
        il ne peut pas pointer par la suite sur une autre valeur. Par contre on peut modifier la valeur point√©e.
  \item Il est possible de placer le qualificateur |const| avant et apr√®s le symbole \verb@*@. Dans ce cas, on d√©clare
        un pointeur constant qui pointe sur une valeur qu'il consid√®re comme constant !
\end{itemize}

Ainsi :

\begin{lstlisting}
int a = 3, b = 4;
const int c = 5;

const int * pt_a = &a;
*pt_a = -a; // Erreur de compilation ! a consid√©r√© constant par le pointeur
pt_a = &b;  // Correct, le pointeur n'est pas constant

int * const pt_b = &b;
*pt_b = -b; // Correct, pt_b pointe sur une valeur consid√©r√©e comme non constant
pt_b = &a; // Erreur de compilation ! pt_b est un pointeur constant.

int const* const pt_c = &a;
*pt_c = -a; // Erreur de compilation ! a consid√©r√© constant par le pointeur
pt_c = &b;  // Erreur de compilation ! le pointeur est constant

int* pt_d = &c; // Erreur de compilation, on ne peut pas cr√©e un pointeur sur une valeur non constante
                // si la valeur point√©e est constante. 
\end{lstlisting}

On peut voir qu'il est interdit de cr√©e un pointeur sur une valeur non constant si on initialise ce pointeur sur une valeur constante. 

Nous allons voir que C++ poss√®de dans sa biblioth√®que standard des pointeurs intelligents qui permettent d'allouer facilement un espace m√©moire pour y stocker dynamiquement (c'est √† dire durant l'ex√©cution du programme) une valeur, mais aussi garantir qu'on ne peut pas lib√©rer deux fois le m√™me espace m√©moire.

\subsubsection{Pointeurs partag√©s}

Les pointeurs partag√©s sont des pointeurs qui "comptent" le nombre de pointeurs qui pointent sur la m√™me variable √† l'aide d'une compteur de r√©f√©rence. 
Lorsqu'on quitte un bloc d'instructions contenant un tel pointeur, ce pointeur d√©cr√©mente le compteur de r√©f√©rence, et si le compteur atteint la valeur z√©ro (plus aucun pointeur ne pointe sur cette valeur), il lib√®re l'espace m√©moire r√©serv√©e pour cette variable.

On cr√©e un tel pointeur en utilisant la fonction |std::make_shared| et en  sp√©cifiant entre $<$ et $>$ le type de valeur point√©e. La fonction r√©serve l'espace m√©moire et initialise dans la foul√©e la valeur voulue en fonction des param√®tres mis entre ses parenth√®ses.

\begin{lstlisting}[caption=Exemple de cr√©ation de pointeurs partag√©s]
struct ficheEtudiant
{
    std::string pr√©nom, nom;
    std::int32_t √¢ge, num√©ro_carte_√©tudiant, promotion;
};
...
int main()
{
    auto pt_i1 = std::make_shared<int>(-4);
    auto pt_fiche1 = std::make_shared<ficheEtudiant>("G√©rard","Chambier", 32, 132493, 2022);
    auto pt_fiche2 = std::make_shared<ficheEtudiant>();

\end{lstlisting}

Notons dans le cas de l'initialisation d'une structure point√©e par un pointeur partag√©, qu'on peut
initialiser compl√®tement ou pas du tout les champs de la structure mais qu'il est impossible 
d'utiliser une initialisation partielle en d√©signant les champs initialis√©s. On verra 
dans le chap√Ætre consacr√© √† la programmation objet comment faire pour permettre de ne faire qu'une initialisation partielle.

Notons √©galement que dans ce cadre, le mot clef |auto| est utilis√© √† bon escient puisque
|std::make_shared| renvoie bien un pointeur partag√© et que resp√©cifier, par exemple, que
|pt_i1| est un pointeur partag√© sur un entier ne ferait qu'alourdir et rendre le code moins lisible :
\begin{lstlisting}[caption=M√™me exemple sans auto]
int main()
{
    std::shared_ptr<int> pt_i1 = std::make_shared<int>(-4);
    std::shared_ptr<ficheEtudiant> pt_fiche1 = 
         std::make_shared<ficheEtudiant>("G√©rard","Chambier", 32, 132493, 2022);
    std::shared_ptr<ficheEtudiant> pt_fiche2 = std::make_shared<ficheEtudiant>();

\end{lstlisting}

Pour conna√Ætre le nombre de pointeurs faisant r√©f√©rence √† une valeur point√©e par un vecteur partag√©,
on utilise la m√©thode |use_count|. Voici un exemple d'utilisation :
\begin{lstlisting}[caption=Lire le nombre de pointeur faisant r√©f√©rence √† une valeur]
auto pt_i = std::make_shared<int>(-4);
std::cout << "Nombre de pointeur se r√©f√©rant √† -4 : " << pt_i.use_count() << std::endl;
{
  auto pt_j = pt_i;
  std::cout << "Nombre de pointeur se r√©f√©rant √† -4 : " << pt_i.use_count() << std::endl;
  {
    auto pt_k = pt_j;
    std::cout << "Nombre de pointeur se r√©f√©rant √† -4 : " << pt_i.use_count() << std::endl;
  }
  std::cout << "Nombre de pointeur se r√©f√©rant √† -4 : " << pt_i.use_count() << std::endl;
}
std::cout << "Nombre de pointeur se r√©f√©rant √† -4 : " << pt_i.use_count() << std::endl;
\end{lstlisting}

qui affichera
\begin{inverseverbatim}
Nombre de pointeur se r√©f√©rant √† -4 : 1
Nombre de pointeur se r√©f√©rant √† -4 : 2
Nombre de pointeur se r√©f√©rant √† -4 : 3
Nombre de pointeur se r√©f√©rant √† -4 : 2
Nombre de pointeur se r√©f√©rant √† -4 : 1
\end{inverseverbatim}

Vous pouvez trouver l'exemple complet dans \verb@Exemples/Pointeurs/shared_pointers.cpp\verb@.

Signalons enfin qu'il est impossible de faire de l'arithm√©tique de pointeurs avec les pointeurs partag√©s.

\subsubsection{Pointeurs uniques}

Les pointeurs uniques sont des pointeurs qui garantissent qu'un et un seul pointeur √† la fois peut pointer sur une valeur sp√©cifique en m√©moire. Il est ainsi impossible d'avoir une copie d'un vecteur unique. Un pointeur unique en C++ est de type |std::unique_ptr| et comme pour les pointeurs partag√©s,
on sp√©cifie le type de la variable point√©e entre $<$ et $>$. 

Comme pour le pointeur partag√©, il est possible √† la fois de r√©server et d'initialiser la variable
qui sera point√©e par le pointeur unique gr√¢ce √† la fonction |std::make_unique|.

\begin{lstlisting}[caption=Exemple d'utilisation des pointeurs uniques]
struct ficheEtudiant
{
    std::string pr√©nom, nom;
    std::int32_t √¢ge, num√©ro_carte_√©tudiant, promotion;
};
...
int main()
{
    auto pt_i = std::make_unique<int>(-4);
    auto pt_j = std::make_unique<int>();
    auto pt_fiche1 = std::make_unique<ficheEtudiant>("Robert", "Chambier", 24, 135395, 2022);
    auto pt_fiche2 = std::make_unique<ficheEtudiant>();
}
\end{lstlisting}

L√† encore, il est possible d'initialiser une structure √† condition d'initialiser tout ses champs.

Comme dit plus haut, il est impossible de recopier un pointeur unique dans un autre pointeur unique.
Il est par contre possible de \textsl{d√©placer} les donn√©es d'un pointeur dans un autre pointeur unique. Cela veut dire que le pointeur \textsl{d√©plac√©} perdra sa r√©f√©rence sur la valeur point√©e.
Ainsi :
\begin{lstlisting}
std::unique_ptr<int> pt_k = pt_i; // Erreur de compilation, copie interdite !
std::unique_ptr<int> pt_l = std::move(pt_i);// OK, on d√©place les donn√©es de pt_i dans pt_l
\end{lstlisting}

Nous avons introduit ici une nouvelle fonction qui permet, non pas de copier la valeur d'une variable
dans une autre variable, mais de \textsl{d√©placer} la valeur d'une variable dans une autre. Ici, apr√®s appel de la fonction |std::move|, |pt_i| a perdu sa r√©f√©rence sur la variable |i|. C'est maintenant |pt_l| qui contient la r√©f√©rence. 

Nous reviendrons plus en d√©tail sur ces op√©rations de d√©placement qui permettent depuis C++ 11
de simplifier l'interface et de mieux optimiser les codes C++.

\subsection{Les r√©f√©rences}

Nous avons vu deux mani√®res de lire ou modifier une valeur : soit un stockant directement cette valeur
en m√©moire √† l'aide d'une variable, soit en stockant dans un pointeur l'adresse du d√©but de la m√©moire occup√©e par cette valeur. Remarquons que dans le deuxi√®me cas, il faut d'une mani√®re ou d'une autre (√† l'aide d'une variable ou bien avec l'allocation dynamique qu'on verra plus loin ) qu'on ait r√©serv√©
de la m√©moire pour stocker cette valeur avant de pointer dessus.

Il existe une troisi√®me fa√ßon d'acc√©der √† une valeur : par r√©f√©rence. Cette mani√®re d'acc√®der √† une valeur peut-√™tre vu comme un "mixte" des deux autres acc√®s : une r√©f√©rence ne permet pas de r√©server et de stocker une valeur directement, elle doit pour cela faire r√©f√©rence √† une variable ou un emplacement m√©moire o√π la valeur est stock√©e (comme pour un pointeur), mais elle permet √©galement d'acc√©der directement √† la valeur √† la mani√®re d'une variable sans devoir passer par un op√©rateur de d√©f√©rencement. Comme son nom l'indique, une r√©f√©rence fait r√©f√©rence √† une valeur, en aucun cas elle ne la stocke. De plus, une r√©f√©rence ne peut pas changer de valeur √† r√©f√©rer, contrairement √† un pointeur !

Le symbole pour d√©finir une r√©f√©rence est le symbole |&|, accol√© (ou non) au type. Elle doit √™tre obligatoirement initialis√©e √† sa d√©claration sur la valeur dont elle doit faire r√©f√©rence.

\begin{lstlisting}
int i = 3;
int& j = i; // j fait r√©f√©rence √† i
j = 4;      // i et j valent maintenant 4 !
\end{lstlisting}

Il est possible de d√©finir des r√©f√©rences avec une d√©duction automatique du type.
Dans le cadre des d√©ductions implicites, il suffit de rajouter le symbole |&| juste apr√®s |auto|.
Dans le cadre des d√©ductions explicites, il faut rajouter des parenth√®ses autour de l'expression
qui permet de d√©duire le type :

\begin{lstlisting}[caption=Exemple de r√©f√©rence avec d√©duction de type automatique]
int i = 3;
auto& j = i; // j fait r√©f√©rence √† i et est de m√™me type
decltype(i) k = i; // k est une variable recopiant la valeur de i
decltype((i)) l = i; // l est une r√©f√©rence √† i.
\end{lstlisting}

Comme on peut le constater, il est important de ne pas mettre de parenth√®se en moins ou en trop
lors de la d√©claration explicite d'un type ! 

Attention, il ne faut pas croire qu'une r√©f√©rence est attach√©e √† une variable ! Elle est attach√©e √† une valeur √† une certaine
position dans la m√©moire.

Ainsi, consid√©rons le code suivant :
\begin{lstlisting}
auto pt_x = std::make_unique<double>(0.303);
auto pt_y = std::make_unique<double>(0.0);
double& x = *pt_x;

std::cout << "*pt_x = " << *pt_x << ", *pt_y = " << *pt_y << " et x = " << x << std::endl;
x = -0.303;
std::cout << "*pt_x = " << *pt_x << ", pt_y = " << *pt_y << " et x = " << x << std::endl;
*pt_x = 0.404;
std::cout << "*pt_x = " << *pt_x << ", pt_y = " << *pt_y << " et x = " << x << std::endl;
*pt_y = -1.;
std::cout << "*pt_x = " << *pt_x << ", pt_y = " << *pt_y << " et x = " << x << std::endl;
std::swap(pt_x,pt_y);
std::cout << "*pt_x = " << *pt_x << ", pt_y = " << *pt_y << " et x = " << x << std::endl;
x = 1.414;
std::cout << "*pt_x = " << *pt_x << ", pt_y = " << *pt_y << " et x = " << x << std::endl;
*pt_x = 2.15;
std::cout << "*pt_x = " << *pt_x << ", pt_y = " << *pt_y << " et x = " << x << std::endl;
*pt_y = 2.28;
std::cout << "*pt_x = " << *pt_x << ", pt_y = " << *pt_y << " et x = " << x << std::endl;
\end{lstlisting}

On aura pour r√©sultat √† l'affichage :

\begin{inverseverbatim}
*pt_x = 0.303, *pt_y = 0 et x = 0.303
*pt_x = -0.303, *pt_y = 0 et x = -0.303
*pt_x = 0.404, *pt_y = 0 et x = 0.404
*pt_x = 0.404, *pt_y = -1 et x = 0.404
*pt_x = -1, *pt_y = 0.404 et x = 0.404
*pt_x = -1, *pt_y = 1.414 et x = 1.414
*pt_x = 2.15, *pt_y = 1.414 et x = 1.414
*pt_x = 2.15, *pt_y = 2.28 et x = 2.28
\end{inverseverbatim}

ce qui montre bien que la r√©f√©rence |x| ici est bien attach√©e √† une valeur en m√©moire (qui peut √™tre modifi√©e)
et non √† une variable !

Nous verrons une utilisation des r√©f√©rences lors de l'appel de fonctions.

\section{Les tableaux}

\subsection{Gestion statique contre gestion dynamique}

En C++, il existe deux fa√ßon de r√©server de la m√©moire sur un ordinateur :
\begin{itemize}
  \item \textbf{L'allocation statique} : la place m√©moire n√©cessaire aux donn√©es qu'on veut stocker (variable ou autre) est connu √† la compilation. C'est donc le compilateur qui lors de la cr√©ation de l'ex√©cutable, r√©servera l'espace n√©cessaire pour stocker les donn√©es dans l'ex√©cutable lui-m√™me;
  \item \textbf{L'allocation dynamique} : la place m√©moire n√©cessaire aux donn√©es qu'on veut stocker n'est pas connu au moment de la compilation. La r√©servation de l'espace m√©moire se fera donc durant l'ex√©cution du programme, √† l'aide d'instructions sp√©cifiques permettant cette allocation. 
\end{itemize}

L'allocation statique ne co√ªte rien en terme de temps d'ex√©cution, au contraire de l'allocation dynamique qui doit faire appel aux services du syst√®me d'exploitation pour obtenir un espace m√©moire r√©serv√© et prot√©g√© (des autres applications).

Par contre, sur certains syst√®mes d'exploitation (en particuliers Windows\ldots), l'allocation statique est limit√©e √† une taille m√©moire qui d√©pend du syst√®me d'exploitation (sous Windows, selon la version du processeur et de Windows, cette limitation est entre 256ko et 512ko). Il est donc pr√©f√©rable d'utiliser l'allocation statique que pour de petites quantit√©s !

\subsection{Gestion dynamique de la m√©moire}

Il est possible de g√©rer dynamiquement la r√©servation et l'initialisation de variables.
Pour cela on utilise l'instruction |new| qui permet d'allouer et d'√©ventuellement initialiser une variable.

La syntaxe de |new| est tr√®s simple : |pointeur = new type_name;| o√π |type_name| est le type de variable qu'on
veut r√©server dynamiquement.

Il est √©galement possible d'initialiser la variable. Dans ce cas, la syntaxe de |new| est : |pointeur = new type_name(arguments)| o√π |arguments| sont les arguments permettant d'initialiser la valeur.

Par exemple :
\begin{lstlisting}
auto pt_int = new int; // On cr√©e dynamiquement un entier point√© par pt_int
auto pt_float = new float; // Idem pour un float point√© par pt_float
auto pt_fiche = new ficheEtudiant; // On cr√©e dynamiquement une valeur de type ficheEtudiant

auto pt_int2  = new int(3);// Cr√©e dynamiquement entier valant 3 point√© par pt_int2
auto pt_float2= new float(3.14);// idem float valant 3.14 point√© par pt_float2
// Initialisation dynamique d'une nouvelle fiche d'√©tudiant
auto pt_fiche2= new ficheEtudiant("Robert"s, "Chambier"s, 32, 345341, 2022);
\end{lstlisting}

Qui dit cr√©ation dynamique dit √©galement destruction dynamique ! Une variable cr√©√©e dynamiquement ne se d√©truira
pas et ne lib√©rera pas la m√©moire automatiquement. C'est √† la charge du programmeur de d√©truire cette variable.
C'est le r√¥le de l'instruction |delete|.

Ainsi, en prenant l'exemple de cr√©ation dynamique ci-dessus, on peut d√©truire et lib√©rer la m√©moire prise par ses
variables par :
\begin{lstlisting}
delete pt_fiche2;
delete pt_float2;
delete pt_int2;
delete pt_fiche;
delete pt_float;
delete pt_int;
\end{lstlisting}

Remarquons que la destruction des variables a √©t√© sciemment faite dans le sens contraire de leur cr√©ation. Ce n'est
bien s√ªr par obligatoire, mais c'est conseill√© pour ne pas laisser de "trous" inutiles en m√©moire qui p√©naliserait
la place m√©moire occup√©e par l'ex√©cutable (mais c'est un sujet un peu complexe √† aborder).

Attention √† bien lib√©rer la place m√©moire avant de perdre le dernier pointeur sur cette valeur. Sinon, il est impossible
d'acc√®der √† la valeur en m√©moire qui restera en m√©moire jusqu'√† la fin de l'ex√©cution du programme. C'est ce qu'on appelle
une fuite m√©moire (memory leak en anglais). Si cette "fuite m√©moire" se fait dans une partie du code appel√©e tr√®s souvent et
r√©guli√®rement, la place m√©moire prise par l'ex√©cutable deviendra de plus en plus grande jusqu'√† ce que le programme "plante" faute de place m√©moire. Ce type d'erreur est tr√®s difficile √† trouver, et des utilitaires comme |valgrind| sous Linux sont une aide tr√®s pr√©cieuse pour d√©tecter ce type d'erreur !

\subsection{Autre fa√ßon de g√©rer la m√©moire dynamiquement}

Si les instructions |new| et |delete| √©taient indispensables avant le C++ 11, elles le sont bien moins depuis !
En effet, nous avons vu qu'il existait des pointeurs partag√©s et uniques qui s'occupent de la r√©servation m√©moire
et de l'initialisation des variables.

L'avantage de ces pointeurs est qu'ils vous garantissent qu'il ne peut y avoir de fuite m√©moire dans votre programme si vous les utilisez. En effet, ils d√©truisent et lib√®rent automatiquement une valeur d√®s qu'il n'y a plus de pointeurs sur cette valeur !

Ainsi, on aurait pu avantageusement remplacer l'allocation vu pr√©c√©demment avec |new| par :
\begin{lstlisting}
auto pt_int = std::make_shared<int>(); 
auto pt_float = std::make_shared<float>();
auto pt_fiche = std::make_shared<ficheEtudiant>;

auto pt_int2  = std::make_shared<int>(3);
auto pt_float2= std::make_shared<float>(3.14);
auto pt_fiche2= std::make_shared<ficheEtudiant>("Robert"s, "Chambier"s, 32, 345341, 2022);
\end{lstlisting}

La d√©sallocation de ces variables se fera automatiquement et permet ainsi une simplification du code tout en le rendant
moins sensibles aux fuites m√©moires !

\underline{Remarque} : On aurait pu remplacer |std::make_shared| par |std::make_unique| si on sait qu'un seul pointeur


\subsubsection{Gestion statique de la m√©moire}

En C (valable aussi en C++), un tableau statique se d√©clare de la mani√®re suivante :
\begin{lstlisting}[caption=Allocation statique d'un tableau en C/C++]
const int N = 10;
double array1[N]; // D√©clation du tableau sans initialisation
double array2[N] = { 1., 2., 3., 4., 5., 6., 7., 8., 9., 10. }; // Avec initialisation
double array3[]  = { 1., 3., 7., 11. };// La taille est d√©termin√©e par la liste d'initialisation { ... }
\end{lstlisting}

Cette d√©claration d'un tableau statique pose quelques probl√®mes. Le compilateur ne v√©rifie pas obligatoirement que la liste d'initialisation poss√®de un nombre de valeurs inf√©rieur ou √©gal √† la taille du tableau :

\begin{lstlisting}
double array[4] = {1., 2., 3., 4., 5.};
\end{lstlisting}

Dans le cas o√π la taille d'un tableau est d√©termin√©e par sa liste d'initialisation, il n'est pas imm√©diat de trouver la taille du tableau :

\begin{lstlisting}[caption=lire la taille d'un tableau statique en C/C++]
double array3[]  = { 1., 3., 7., 11. };// La taille est d√©termin√©e par la liste d'initialisation { ... }
int size_of_array3 = sizeof(array3)/sizeof(double); // Calcul de la taille du tableau statique
\end{lstlisting}

De plus, l'acc√®s aux √©l√©ments du tableau n'est pas prot√©g√© et il est facile de se tromper dans les indices et lire des valeurs en dehors du tableau :
\begin{lstlisting}[caption=Erreur d'indice]
double array3[]  = { 1., 3., 7., 11. };// La taille est d√©termin√©e par la liste d'initialisation { ... }
double x = 0.;
for ( int i = 0; i < sizeof(array3); ++i )// Erreur sur la taille du tableau !!!!
    x += array3[i];                       // Et donc d√©passement du tableau et mauvais calcul...
\end{lstlisting}

\underline{Remarque 1} : L'exemple ci-dessus √† permis d'introduire la liste d'initialisation, c'est √† dire un ensemble de valeurs d√©finies entre deux accolades $\{$ et $\}$ qui permettent d'initialiser une collection de valeurs (comme un tableau). La liste d'initialisation est un objet important du C++ √† partir de sa version C++ permettant une grande souplesse dans l'initialisation des objets (voir le cours sur l'objet qu'on fera plus tard.)

\underline{Remarque 2} : Attention, dans l'exemple ci--dessus, la variable N est bien d√©clar√©e comme \textbf{constante}, ce qui permet de d√©finir des tableaux statiques de dimension N. Cependant, si N n'est pas constant, rien ne garantit que votre code compilera sur tous les compilateurs. C'est en fait une extension du compilateur gnu C qui permet d'allouer un tableau statique de fa√ßon dynamique (sic !) mais qui ne marchera pas sur des compilateurs comme celui de microsoft, intel, \ldots

En C++, depuis C++ 11, il existe une solution plus s√ªre et plus conviviale, permettant de v√©rifier (en particuliers en mode d√©veloppement) ou de prot√©ger l'acc√®s aux donn√©es du tableau. Il faut pour cela utiliser |array| de la biblioth√®que standard du C++.

La construction d'un tableau statique en C++ ressemble beaucoup √† la construction faite en C, mais avec beaucoup plus de v√©rifications quant √† la construction du tableau :

\begin{lstlisting}
#include <iostream>
#include <array> 

int main()
{
    // D√©claration d'un tableau statique de dimension quatre contenant des entiers non initialis√©s
    std::array<int,4> iarray4;

    // D√©claration d'un tableau statique de dimension cinq contenant des doubles initialis√©s par une liste
    std::array<double,5> darray5({ 1.2, 2.3, 3.4, 4.3, 3.2});

    // Autre √©criture pour initialiser un tableau statique de dimension quatre contenant des doubles initialis√©s par une liste
    std::array<double,4> darray4 = { 1.2, 2.3, 3.4, 4.3 };

    // A partir de C++ 17, il est possible d'omettre le type et la taille si on donne une liste de valeurs :
    std::array darray6 = { 1., 2., 3., 4., 5., 6.}; // Equivalent √† std::array<double,6> pour le type

    // Si la taille est pr√©cis√©e, le C++ v√©rifie qu'on a pas une liste contenant plus de valeurs que la dimension du tableau
    std::array<double,4> darray4_2 = { 1.2, 2.3, 3.4, 4.3, 3.2 };// Erreur √† la compilation 
    ...

}
\end{lstlisting}

On acc√®de aux √©l√©ments du tableau de la m√™me mani√®re qu'un tableau statique en C, mais avec une possibilit√© de v√©rification de l'indice pass√© en plus :

\begin{lstlisting}
    // On lit le premier √©l√©ment du tableau darray5 : x devient un alias constant sur ce premier √©l√©ment
    const double& x = darray5[0];
    // On lit le cinqui√®me √©l√©ment d'un tableau de dimension quatre ! Si -D_GLIBCXX_DEBUG a √©t√© mis en option de compilation
    // l'ex√©cutable s'arr√®te en signalant qu'un mauvais indice a √©t√© pass√© au tableau !
    double y = darray4[4];
    // Bien s√ªr, on peut √©galement modifi√© un √©l√©ment d'un tableau :
    darray4[2] = 3.14;
\end{lstlisting}

D'autres services non pr√©sent pour le tableau statique de type C sont disponibles. Notez la fa√ßon d'appeler ces fonctions, appel√©es m√©thodes, o√π on √©crit le nom de l'objet sur lequel le traitement doit √™tre effectu√©, suivi d'un point et du nom de la m√©thode √† appeler sur cet objet :

\begin{lstlisting}
    // Lire la dimension du tableau (son nombre d'√©l√©ments)
    auto sz = iarray4.size();
    // Remplir le tableau avec une valeur donn√©e en param√®tre :
    iarray4.fill(-1); // Remplit le tableau iarray4 avec la valeur -1.
    // On peut aussi comparer des tableaux lexicographiquement :
    std::array<int,4> iarray4_2 = {-1, -2, 1, -1};
    if (iarray4_2 < iarray4) 
        std::cout << "iarray4_2 inf√©rieur √† iarray4" << std::endl;
\end{lstlisting}

Il est √©galement possible de parcourir de fa√ßon ``automatique'' les √©l√©ments d'un tableau. Pour cela, on doit introduire un concept du C++ qui s'applique non seulement aux tableaux statiques, mais √† un grand nombre de conteneurs : \textbf{les it√©rateurs}

Un it√©rateur est un objet qui, pointant sur des √©l√©ments d'un tableau ou d'un conteneur poss√®de la propri√©t√© d'it√©rer au travers des √©l√©ments du conteneur en utilisant un ensemble d'op√©rations (l'incr√©ment |++| en particuliers et l'op√©rateur de d√©f√©rencement |*|). 

La forme la plus basique d'it√©rateur est le pointeur en C, qui pointe sur un √©l√©ment d'un tableau et peut it√©rer en utilisant l'op√©rateur |++| (pr√© ou post) pour parcourir les √©l√©ments du tableau.. Mais d'autres types d'it√©rateurs sont possibles. Par exemple on peut d√©finir un it√©rateur permettant de parcourir une liste dont les √©l√©ments ne sont pas contig√ºs en m√©moire. 

Il faut remarquer qu'un pointeur est un type d'it√©rateur, mais que ce n'est pas tous les it√©rateurs qui ont les m√™mes fonctionnalit√©s que les pointeurs. On peut classifier les it√©rateurs en cinq cat√©gories : Les it√©rateurs d'entr√©e, de sortie, les it√©rateurs uni-directionnels, les it√©rateurs bi-directionnels et les it√©rateurs √† acc√®s randomis√©s.

\begin{enumerate}
  \item \textbf{Les it√©rateurs d'entr√©e et de sortie} : ce sont les it√©rateurs les plus limit√©s. Ils ne peuvent que parcourir en lisant qu'une seule fois les √©l√©ments d'un tableau en lecture ou √©criture (pensez √† un it√©rateur sur un fichier par exemple ou des donn√©es lues sur un port s√©rie, etc.);
  \item \textbf{Les it√©rateurs uni-directionnels} : Ils ont toutes les fonctionnalit√©s d'un it√©rateur de sortie et d'entr√©e si il n'est pas constant. Il est possible de lire ou √©crire plusieurs fois le m√™me √©l√©ment mais on ne peut qu'it√©rer que du premier ou dernier √©l√©ment ou du dernier √©l√©ment au premier. Tous les it√©rateurs des conteneurs sont au minimum des it√©rateurs uni-directionnels. Un exemple d'it√©rateur uni-direcionnel est un it√©rateur sur une liste simple cha√Æn√©e.
  \item \textbf{Les it√©rateurs bi-directionnels} : similaire aux it√©rateurs uni-directionnels, sauf qu'il est possible d'it√©rer en avant ou en arri√®re (avec l'op√©rateur |--|)
  \item \textbf{Les it√©rateurs √† acc√®s randomis√©s} : Ce sont les it√©rateurs qui ressemblent aux pointeurs. Il est possible de sauter plusieurs √©l√©ments en avant ou en arri√®re et dont lire les √©l√©ments d'un conteneur de fa√ßon ``al√©atoire'' en utilisant une arithm√©tique semblable √† celle des pointeurs.
\end{enumerate}

Pour acc√©der aux it√©rateurs d'un conteneur, le conteneur propose de fa√ßon standard deux m√©thodes : |begin()| qui cr√©e un it√©rateur sur le d√©but du conteneur et |end()| qui cr√©e un it√©rateur pointant sur l'adresse m√©moire suivant le dernier √©l√©ment du conteneur. Ainsi, dans le cas d'un objet de type |array|, on peut parcourir tous ces √©l√©ments comme dans l'exemple suivant :

\begin{lstlisting}[caption=utilisation explicite des it√©rateurs pour array]
    std::cout << "darray4 : ";
    for ( auto iter = darray4.begin(); iter != darray4.end(); ++iter )
        std::cout << *iter << " ";// <-- notez le d√©f√©rencement
    std::cout << std::endl;
\end{lstlisting}

Depuis le C++ 11, on peut ``cacher'' l'utilisation de ces it√©rateurs √† l'aide d'une √©criture plus simple de la boucle |for| (et cela est valable pour tout objet poss√©dant des it√©rateurs). La boucle de l'exemple suivant parcourt automatiquement tous les √©l√©ments de |darray5| (en prenant chaque √©l√©ment en r√©f√©rence constante pour √©viter une copie) :
\begin{lstlisting}[caption=utilisation implicite des it√©rateurs pour array]
    std::cout << "darray5 : ";
    for ( const double& val : darray5 ) std::cout << val << " ";
    std::cout << std::endl;
}
\end{lstlisting}

\subsubsection{Gestion dynamique de la m√©moire}

En C, il n'y a gu√®re le choix : on alloue dynamiquement un tableau √† l'aide de l'instruction |malloc| dont on re√ßoit l'adresse de d√©but dans un pointeur. Il faut ensuite lib√©rer cet espace m√©moire lorsqu'on n'en a plus besoin √† l'aide de l'instruction |free| :

\begin{lstlisting}
int n;
...
double* pt_array = (double*)malloc(n*sizeof(double));
...
free(pt_array);
\end{lstlisting}

En C++, pour des raisons d'initialisation de certains objets, il est d√©conseill√© d'utiliser |malloc| et |free|. Il est pr√©f√©rable d'utiliser leur √©quivalent (√† l'initialisation des objets pr√®s) : |new| et |delete| dont l'√©criture est moins lourde :
\begin{lstlisting}[caption=Exemple d'utilisation de new et delete]
int * pt_n = new int; // On r√©serve une variable enti√®re
int& n = *pt_n;

double* pt_pi = new double(3.1415); // R√©serve un double et l'initialise √† 3.1415
...
double* pt_array = new double[n];// On r√©serve un tableau de n doubles
...
delete [] pt_array; // On lib√®re un tableau dynamique
delete pt_n;        // On lib√®re une variable dynamique
\end{lstlisting}

\textbf{\textcolor{red}{Attention}} : Il est interdit de d√©sallouer un tableau allouer avec |malloc| avec un |delete| sous peine d'erreurs m√©moires lors de l'√©x√©cution. De m√™me il ne faut pas lib√©rer √† l'aide de |free| un tableau allou√© avec |new|.

N√©anmoins, principalement √† partir du C++ 11, l'utilisation de |new| et |delete| n'est utile que dans certains contextes particuliers. On pr√©f√©rera pour cr√©er un tableau dynamique utiliser l'objet |vector| de la biblioth√®que du m√™me nom qui permet une gestion automatique de la m√©moire sans avoir √† s'occuper de la lib√©ration de la m√©moire (qui se fera automatiquement lors de la sortie du bloc d'instruction o√π a √©t√© d√©clar√© le tableau) :

\begin{lstlisting}
// R√©serve un tableau dynamique de trente entiers qui se d√©truira quand il ne sera plus visible
std::vector<int> indices(30); 
// D√©clare un tableau de doubles :
std::vector<double> tableau;
// Et r√©serve ensuite 10 √©l√©ments :
tableau.resize(10);
// Autre possibilit√© pour r√©server une nouvelle taille
// en perdant les √©l√©ments d√©j√† contenus mais c'est plus rapide que resize :
std::vector<double>(20).swap(tableau);
// Cr√©er dynamiquement un tableau de 10 r√©els donn√©s dans une liste d'initialisation
// Notez que le type n'a pas besoin d'√™tre pr√©cis√© puisque la liste contient des doubles (d√©duction automatique : C++ 17)
std::vector tab2 = {1., 2., 3., 4., 5., 6., 7., 8., 9., 10. };
// On realloue le tableau tab2 √† ving √©l√©ments (en conservant les dix premiers √©l√©ments)
tab2.resize(20);
// Alloue un tableau d'entiers de dimension 100 rempli de -1:
// L√† encore, on ne pr√©cise pas le type car on passe un entier pour valeur de remplissage (d√©duction automatique) :
std::vector ind2(100,-1);
// Et l√† on alloue un tableau de r√©el rempli de 3.14
std::vector pi_array(100,3.14);
// Cr√©ation d'un tableau recopiant les donn√©es d'un autre conteneur via les it√©rateurs :
std::vector<double> copie(tab2.begin(), tab2.end());
// Et plus simple encore, copie du tableau ind2 dans un nouveau tableau d'entier
std::vector<int> ind3(ind2);
\end{lstlisting}

Pour interagir avec des librairies C ou d'autres langage, il est possible de lire l'adresse du premier √©l√©ment (valable aussi pour |array| ! ) :
\begin{lstlisting}
double* pt_tab2 = tab2.data();
\end{lstlisting}

Il est bien s√ªr possible de lire ou √©crire dans un tableau de type |vector| :
\begin{lstlisting}
// Lit le quatri√®me √©l√©ment
double x = tab2[3];
// Ecrit le cinqui√®me √©l√©ment
tab2[5] = 3.14;
// Lit le premier √©l√©ment (on peut aussi √©crire dessus)
double p = tab2.front();
// Ecrit le dernier √©l√©ment (on peut aussi seulement le lire)
tab2.back() = -3.14;
\end{lstlisting}

On peut √©galement changer les donn√©es de deux pointeurs √† condition qu'ils aient des √©l√©ments de m√™me type :
\begin{lstlisting}
// Echange des donn√©es entre tab2 et tableau :
tab2.swap(tableau);
\end{lstlisting}

La gestion m√©moire √©tant optimiser au mieux, il se peut que le tableau que vous manipulez ait une taille inf√©rieure √† la r√©servation m√©moire effectivement faite. Pour conna√Ætre la taille du tableau ou reallouer le tableau de sorte que la r√©servation m√©moire corresponde √† la taille.
On peut √©galement pr√©r√©server une taille m√©moire pour remplir ensuite le tableau √©l√©ment par √©l√©ment sans avoir √† faire de reallocation.

\begin{lstlisting}
// Lire le nombre d'√©l√©ments contenus dans le tableau :
auto sz = tab2.size();
// Realloue le tableau de sorte que la m√©moire soit optimis√©e (C++ 11) :
tab2.shrink_to_fit(); 
// Cr√©ation tableau vide :
std::vector<double> an_array;
// R√©servation de 10 doubles dans le tableau (mais toujours avec 0 √©l√©ments)
an_array.reserve(10);
// Puis on rajoute les √©l√©ments un √† un :
for ( int i = 0; i < 10; ++i )
    // En rajoutant chaque √©l√©ment √† la fin du tableau :
    an_array.push_back(3.1415*i);
// Le tableau aura bien 10 √©l√©ments √† la fin avec une seule allocation avec l'appel √† reserve
\end{lstlisting}

\section{Les fonctions}

Une fonction est une entit√© qui peut prendre en entr√©e des param√®tres, 
ex√©cute un algorithme et retourne √©ventuellement une valeur. La syntaxe
pour d√©clarer une fonction est \verb@[type retour] [nom fonction]([liste de param√®tres]);@.
On d√©clare typiquement une fonction dans un header (un fichier avec l'extension |.hpp|).
Pour d√©finir une fonction, c'est √† dire mettre en {\oe}uvre l'algorithme permettant √† la fonction
de remplir son contrat, la syntaxe ressemblera √†
\begin{verbatim}
[type retour] [nom fonction]([liste param√®tres])
{
  // Bloc d'instructions
}
\end{verbatim}

La d√©finition sera √©crite dans le fichier |.cpp| correspondant au fichier contenant la d√©claration.

Ainsi, si on a √©crit une fonction permettant de calculer la racine d'un entier en renvoyant l'entier le plus proche de la racine de ce nombre, on d√©clarera la fonction dans un header, par exemple
|imath.hpp| :
\begin{lstlisting}[caption=Fichier imath.hpp]
#ifndef _IMATH_HPP_
#define _IMATH_HPP_

int sqrt(int i);

#endif
\end{lstlisting}
et le corps de la fonction dans le fichier |imath.cpp| :
\begin{lstlisting}[caption=Fichier imath.cpp]
#include "imath.hpp"

int sqrt(int i)
{
  ... // L'algorithme pour calculer la racine enti√®re
}
\end{lstlisting}

Le include dans le fichier |imath.cpp| n'est pas n√©cessaire mais permet n√©anmoins
de s'assurer que la signature de la fonction (ses arguments) est la m√™me dans le
header que dans le fichier de mise en {\oe}uvre.

Le corps de la fonction, aux arguments pr√®s, ressemble beaucoup au |main| vu depuis le d√©but. |main| est en fait une fonction, la fonction principale qui sera toujours appel√©e
en premier √† l'ex√©cution.

En g√©n√©ral, un header ne va pas contenir une seule fonction, mais plusieurs fonctions
regroup√©e autour d'un m√™me th√®me. Par exemple, on pourra d√©clarer et mettre en {\oe}uvre
dans |imath| toutes les fonctions effectuant des calculs sur les entiers : puissance ni√®me d'un entier, test de primalit√©, d√©veloppement p-adique d'un entier, r√©solution d'√©quations sur $\mathbb{N}$, etc.

On pourra √©galement regrouper une structure et toutes les fonctions effectuant des traitements sur cette structure au sein d'un m√™me fichier d'ent√™te.

\subsection{Surcharge de fonctions}

Il arrive souvent, en calcul scientifique en particuliers, de devoir √©crire plusieurs versions d'une m√™me fonction pour des types diff√©rents. Par exemple, en alg√©bre lin√©aire, il est utile d'avoir une fonction permettant de faire l'op√©ration $y\leftarrow y + a.x$
o√π $x$ et $y$ sont des vecteurs d'un certain espace vectoriel $\mathbb{K}^{n}$ (o√π
$\mathbb{K}$ est un corps tel que les rationnels, les r√©els, les complexes,
$\mathbb{Z}/p.\mathbb{Z}$ ($p$ premier), etc. et $a$ un scalaire appartenant au corps 
$\mathbb{K}$.

On aimerait pouvoir √©crire des fonctions pour cette op√©rations pour au moins trois types de scalaires diff√©rents en C++ : les r√©els simple pr√©cision, les r√©els double pr√©cision, les complexes simple pr√©cision et les complexes double pr√©cision. Dans un langage tel que le Fortran ou le C, nous serions oblig√© d'appeler ces quatre fontions par des noms diff√©rents ( et de fait, dans la biblioth√®que d'alg√©bre lin√©aire BLAS, les quatre fonctions effectuant cette op√©ration sur les quatre types de scalaires suscit√©s sont nomm√©es saxpy, daxpy, caxpy et zaxpy). En C++, il est possible d'appeler ces quatre fonctions par le m√™me nom, du moment que le type ou le nombre de param√®tre est diff√©rent. Lors de l'appel de la fonction, le type ou le nombre de param√®tres pass√©s permettra sans ambig√ºit√© au compilateur de savoir quel fonction appel√©e.

Ainsi en C++, il est possible d'√©crire les deux fonctions ci--dessus :

\begin{lstlisting}[caption=Exemple de surcharge d'une fonction C++]
// Fonction avec flottants simple pr√©cision
void axpy(int N, float a, const float* x, float* y)
{   // Op√©ration y <- y + a.x sur des vecteurs x,y avec a scalaire
    int i;
    for (i = 0; i < N; ++i ) y[i] += a*x[i];
}

// Fonction avec flottants double pr√©cision
void axpy(int N, double a, const double* x, double* y)
{   // Op√©ration y <- y + a.x sur des vecteurs x,y avec a scalaire
    int i;
    for (i = 0; i < N; ++i ) y[i] += a*x[i];
}
\end{lstlisting}

Ici, le compilateur d√©cidera quelle fonction appeler en fonction du type des param√®tres pass√©s, ainsi
\begin{lstlisting}[caption=Appel √† des fonctions surcharg√©es]
void main()
{
    float fx[] = {1.f, 2.f, 3., 4.f};
    float fy[] = {0.f, -1.f, -2.f, -3.f};
    axpy(4, 2.f, fx, fy);// Appel la fonction avec les flottants simple pr√©cision

    double dx[] = {1., 2., 3., 4.};
    double dy[] = {0., -1., -2., -3.};
    axpy(4, 2., dx, dy); // Appel la fontion avec les flottants double pr√©cision

    axpy(4,2.f, dx, dy);// Erreur de compilation, m√©lange simple et double pr√©cision !
                        // Le compilateur ne peut d√©cider quel fonction appeler...
}
\end{lstlisting}

Il est important de bien respecter le type des param√®tres pass√©s √† l'appel de la fonction sous peine d'avoir des erreurs de compilation parfois fort peu compr√©hensibles !

Nous verrons au chapitre des templates qu'il peut √™tre important d'appeler des fonctions faisant le m√™me traitement mais avec des types diff√©rents par le m√™me nom.

\subsection{Fonction g√©n√©rique (C++ 2020)}

Si on observe attentivement les codes √©crits dans leurs versions simple ou double pr√©cision
(mais √©galement en complexe), on se fera vite la remarque que ces fonctions poss√®dent exactement le m√™me code, au type de variable pr√®s !

Une possibilit√© serait de d√©finir un type en amont de la fonction, qu'on pourrait changer selon le besoin :
\begin{lstlisting}
using scalar_t = double;

...

void axpy(int N, scalar_t a, const scalar_t* x, scalar_t* y)
{   // Op√©ration y <- y + a.x sur des vecteurs x,y avec a scalaire
    int i;
    for (i = 0; i < N; ++i ) y[i] += a*x[i];
}
\end{lstlisting}

Tant que le code utilisant cette fonction ne s'en sert que pour un type de scalaire, c'est une solution viable, bien que peu pratique (il faut penser √† modifier le type de |scalar_t| pour chaque nouveau programme qu'on veut compiler), mais comment faire d√®s lors qu'une application a besoin de la fonction pour diff√©rents types de scalaires ?

C'est l√† que la notion de fonction g√©n√©rique intervient. Une fonction g√©n√©rique est une sorte de patron (template) de fonction, sur lequel le compilateur va s'appuyer pour g√©n√©rer des fonctions selon les types de param√®tres pass√©s √† la fonction. Si on passe des r√©els simple pr√©cision, une fonction sera g√©n√©r√©e pour consid√©rer des r√©els simples pr√©cisions,
si des doubles sont employ√©es, une fonction sera g√©n√©r√©e pour consid√©rer des r√©els double pr√©cisions, etc.

Nous verrons plus loin dans le cours un moyen de faire cela en C++, depuis la premi√®re norme de C++, √† l'aide des patrons (template) qui sont un concept donnant une grande puissance au langage C++ mais aussi les plus beaux mal de t√™te du monde ! (On peut faire des choses tr√®s (trop ?) complexes avec les templates). Mais depuis C++ 20, il est possible
√† l'aide d'une √©criture bien plus simple d'√©crire des fonctions g√©n√©riques, et cela gr√¢ce
au mot clef |auto| !

\begin{lstlisting}[caption=utilisation du mot clef auto pour d√©clarer les param√®tres de la fonction]
// Fonction g√©n√©rique pour tout type de vecteur
void axpy(int N, auto a, const auto x, auto y)
{   // Op√©ration y <- y + a.x sur des vecteurs x,y avec a scalaire
    for (int i = 0; i < N; ++i ) y[i] += a*x[i];
}

void main()

    float fx[] = {1.f, 2.f, 3., 4.f};
    float fy[] = {0.f, -1.f, -2.f, -3.f};
    axpy(4, 2.f, fx, fy);// Appel la fonction avec les flottants simple pr√©cision

    double dx[] = {1., 2., 3., 4.};
    double dy[] = {0., -1., -2., -3.};
    axpy(4, 2., dx, dy); // Appel la fonction avec les flottants double pr√©cision

    axpy(4,2.f, dx, dy);// Appel la fonction avec a en simple pr√©cision, dx et dy en double
}
\end{lstlisting}

Ici la fonction \texttt{axpy} a √©t√© g√©n√©ralis√©e pour prendre n'importe quel type pour \texttt{a, x} et \texttt{y}.
Au fur et √† mesure des diff√©rents appels √† cette fonction "g√©n√©rique", le compilateur produire plusieurs versions de la fonction qui prendra en param√®tre les divers types pass√©s pour \texttt{a, x} et \texttt{y}. Ainsi, dans l'exemple ci-dessus,
trois versions de la fonction seront g√©n√©r√©es : une avec trois r√©els simple pr√©cision, une avec trois r√©els double pr√©cision et la derni√®re avec |a| r√©el simple pr√©cision et |x| et |y| d√©clar√©es comme r√©els double pr√©cision.

Les types (qui peuvent √™tre tous diff√©rents) de \texttt{a, x} et \texttt{y}
seront valides tant que l'op√©ration |y[i] += a*x[i]| reste valide pour les types pass√©s pour les trois arguments. Ainsi la ligne suivante ne compilera pas :

\begin{lstlisting}
void main()
{
    double dx[] = {1., 2., 3., 4.};
    double dy[] = {0., -1., -2., -3.};
    axpy(4, "toto", dx, dy); // Ne compile pas ! Pas de sens de faire y[i] += "toto"*x[i]  
}
\end{lstlisting}

\underline{Remarque} : Si le mot clef |auto| en C++ 20 permet de cr√©er facilement des fonctions g√©n√©riques, il ne permet pas un contr√¥le fin des types permis contrairement aux templates que l'on verra plus tard. N√©anmoins, dans beaucoup de cas, cette
g√©n√©ricit√© est suffisante et bien plus l√©g√®re √† l'√©criture que les templates\ldots

Par contre, si vous avez d√©fini ce que veut dire par exemple la multiplication d'un entier
avec une cha√Æne de caract√®re (ce qui est possible en C++, on verra cela plus loin lorsqu'on parlera des op√©rateurs), il est tout √† fait l√©gitime d'√©crire la ligne suivante :
\begin{lstlisting}
axpy(4, 3, "toto"s, "titi"s);
\end{lstlisting}

Bien s√ªr, il est d√©conseill√© de le faire, car cela rajoute plus de confusion au code qu'autre chose...

\subsubsection{Valeur par d√©faut}

Si nous pouvons d√©j√† √™tre satisfait de notre fonction "g√©n√©rique", on pourra vous faire
n√©anmoins remarquer que si votre fonction s'applique bien √† des vecteurs dont les c{\oe}fficients sont contig√ºs en m√©moire, votre fonction ne pourra effectuer son op√©ration d√®s lors que les c{\oe}fficients de votre vecteur sont espac√©s r√©guli√®rement en m√©moire. Par exemple, si vous avez une matrice rang√©e par ligne (l'indice des colonnes varie le plus vite), vous pouvez souhaiter effectuer votre op√©ration |axpy| sur deux colonnes de votre matrice. Seulement, les coefficients sont alors espac√©s du nombre de colonnes que poss√®de votre matrice ! Pour g√©n√©raliser votre fonction aux vecteurs lignes ou colonnes des matrices, il suffit donc de rajouter deux param√®tres, |incx| et |incy| qui vous donnent
le nombre d'√©l√©ments √† "sauter" pour trouver le prochain c{\oe}fficient d'un des deux vecteurs.

Votre fonction devient donc :
\begin{lstlisting}[caption=G√©n√©ralisation de la fonction axpy]
void axpy(int N, auto a, const auto* x, auto* y, int incx, int incy)
{
    for ( int i = 0; i < N; ++i ) y[i*incy] += a*x[i*incx];
}

int main()
{
    const int N = 4;
    double A[N][N] = { {1,2, 4,  8}, 
                       {1,3, 9, 27},
                       {1,4,16, 64},
                       {1,5,25,125} };
    // On soustrait quatre fois la colonne 1 √† la colonne 3 de la matrice :
    axpy(4, -4., A, A+2, N, N);
    // Rajout de la deuxi√®me colonne √† la quatri√®me ligne :
    axpy(4, 1., A+1, &A[3][0], N, 1]);
}
\end{lstlisting}

Pour l'exemple donn√© ci--dessus, il est clair que les param√®tres |incx| et |incy| sont indispensables. 
N√©anmoins, cela alourdit votre code, principalement pour les vecteurs dont les √©l√©ments sont contig√ºs en m√©moire, ce qui repr√©sente la majorit√© des cas rencontr√©s. En effet, 
il faut √† chaque fois pour ce dernier cas, rajouter deux param√®tres valant un √† la fonction, sans parler du risque de bogue en rajoutant ces deux param√®tres (en mettant par erreur deux au lieu de un pour l'un des param√®tres par exemple).

Heureusement, C++ pr√©voit ces cas, et il est possible de fournir pour ces param√®tres des valeurs par d√©faut ce qui permettra de les omettre lors d'un appel "usuel".

Dans le cas de la fonction |axpy|, on vient de voir que dans la majorit√© des appels √† cette fonction, les param√®tres |incx| et |incy| valent un. On peut donc d√©finir notre fonction en rajoutant pour ces deux param√®tres un pour valeur par d√©faut :
\begin{lstlisting}[caption=Valeurs par d√©faut pour la fonction axpy]
void axpy(int N, auto a, const auto* x, auto* y, int incx = 1, int incy = 1)
{
    for ( int i = 0; i < N; ++i ) y[i*incy] += a*x[i*incx];
}

int main()
{
    const int N = 4;
    double A[N][N] = { {1,2, 4,  8}, 
                       {1,3, 9, 27},
                       {1,4,16, 64},
                       {1,5,25,125} };
    double x[N] = {1,2,3,4};
    double y[N] = {4,3,2,1};
    // On soustrait quatre fois la colonne 1 √† la colonne 3 de la matrice :
    axpy(N, -4., &A[0][0], &A[0][2], N, N); // incx = N, incy = N
    // Rajout de la deuxi√®me colonne √† la quatri√®me ligne :
    axpy(N, 1., &A[0][1], &A[3][0], N);// incx = N, incy = 1
    // Rajout de la deuxi√®me ligne √† la quatri√®me colonne :
    axpy(N, 1., &A[1][0], &A[0][3], 1, N); // incx = 1, incy = N
    // Op√©ration sur les vecteurs x et y :
    axpy(4, 1., x, y); // incx = 1, incy = 1;

    return EXIT_SUCCESS;
}
\end{lstlisting}

\underline{Remarques} :
\begin{enumerate}
    \item Les param√®tres ayant des valeurs par d√©faut doivent \textbf{imp√©rativement} √™tre d√©clar√©e en dernier dans les param√®tres de la fonction;
    \item L'ordre des param√®tres par d√©faut doit √™tre respect√© √† l'appel : si un param√®tre poss√©dant une valeur par d√©faut doit √™tre d√©fini avec une valeur sp√©cifique, \textbf{tous les param√®tres pr√©c√©dents}, m√™me ceux ayant une valeur par d√©faut, doivent √©galement avoir une valeur sp√©cifique d√©finie par l'utilisateur. Ainsi, dans l'exemple ci--dessus, on ne peut pas d√©finir une valeur diff√©rente de un pour |incy| sans d√©finir explicitement la valeur un pour |incx| √† l'appel !
\end{enumerate}

\subsection{Passage par r√©f√©rence}

CONTINUER ICI, SEPARER PASSAGE ET RETOUR PAR REFERENCE

Nous avons vu deux mani√®res de lire ou modifier une valeur : soit un stockant directement   cette valeur
en m√©moire √† l'aide d'une variable, soit en stockant dans un pointeur l'adresse du d√©but de la m√©moire occup√©e par cette valeur. Remarquons que dans le deuxi√®me cas, il faut d'une mani√®re ou d'une autre (√† l'aide d'une variable ou bien avec l'allocation dynamique qu'on verra plus loin ) qu'on ait r√©serv√©
de la m√©moire pour stocker cette valeur avant de pointer dessus.

Il existe une troisi√®me fa√ßon d'acc√©der √† une valeur : par r√©f√©rence. Cette mani√®re d'acc√®der √† une valeur peut-√™tre vu comme un "mixte" des deux autres acc√®s : une r√©f√©rence ne permet pas de r√©server et de stocker une valeur directement, elle doit pour cela faire r√©f√©rence √† une variable ou un emplacement m√©moire o√π la valeur est stock√©e (comme pour un pointeur), mais elle permet √©galement d'acc√©der directement √† la valeur √† la mani√®re d'une variable sans devoir passer par un op√©rateur de d√©f√©rencement. 

En C, il n'existe que deux mani√®res d'acc√©der √† une variable en m√©moire, soit directement en lisant la valeur de la variable  ou via un pointeur repr√©sentant l'addresse du d√©but de la m√©moire occup√©e par la variable.

\begin{lstlisting}
int main()
{
    double x[] = {1., 2., 3. , 4.};
    double y = x[0]; // On acc√®de directement √† la valeur de x[0];
    double* pt_x1 = x + 1;// Pointe sur le deuxi√®me √©l√©ment du tableau x
    double z = *pt_1; // Lis via le pointeur la valeur de deuxi√®me √©l√©ment du tableau x (d√©f√©rencement)
    return EXIT_SUCCESS;    
}
\end{lstlisting}

En C++, il existe une troisi√®me mani√®re d'acc√©der √† la valeur d'une variable : par r√©f√©rence. 

Techniquement, une r√©f√©rence n'est rien d'autre qu'un pointeur constant automatiquement d√©f√©renc√©. Plus prosa√Øquement, une r√©f√©rence est un alias (un nom) qu'on va donner √† une variable en m√©moire, m√™me si elle est d√©j√† nomm√©e par le programme. Pour d√©clarer une r√©f√©rence, on utilise le symbole \&. Par exemple :

\begin{lstlisting}[caption=Exemple de r√©f√©rence en C++]
int main()
{
    int i = 3;
    // ii est un alias sur la variable i.
    int& ii = i; 
    /********************************************************
     *   ii et i repr√©sentent concr√®tement la m√™me variable *
     * qui poss√©de deux noms diff√©rents                     *
     ********************************************************/
    ii = 2; // Maintenant i et ii valent deux, puisque c'est la m√™me variable !
    /************************************************
     * Alias sur la variable, mais on ne pourra pas *
     * la changer via ci, seulement la lire.        *
     ************************************************/
    const int& ci = i;    
    ci = 3; // Erreur, ci est d√©clar√©e const.
}
\end{lstlisting}

Puisqu'une r√©f√©rence cr√©e un alias sur une variable, il est n√©cessaire de s'assurer que cette variable existe au moins tant que la r√©f√©rence sur cette variable existe. Ainsi, si il est parfaitement possible de retourner une r√©f√©rence √† la sortie d'une fonction, il faut \textbf{que la variable retourn√©e ne soit pas locale √† la fonction sous peine de graves probl√®mes √† l'ex√©cution}.

Ainsi, le code suivant est valide et ne pose aucun probl√®me :

\begin{lstlisting}{caption=Exemple complet et valide de retour d'une r√©f√©rence par une fonction}
#include <iostream>

int& max(int N, int* array)
{   // Retourne une r√©f√©rence sur la valeur la plus grande du tableau
    int imax = 0;
    for ( int i = 1; i < N; ++i) {
        if (array[i]>array[imax])
            imax = i;
    }
    return array[imax];
}

void display_array(int N, const int* array )
{
    std::cout << "[ ";
    for ( int i = 0; i < N; ++i ) std::cout << array[i] << " ";
    std::cout << "]" << std::endl;
}

int main()
{
    const int N = 8;
    int array[N] = {1,2,5,6,3,9,10,8};
    display_array(N, array);

    for ( int n = 0; n < 10; ++n ) {
        int& a = max(N,array);
        a = a - 1;
        display_array(N, array);
    }
    return EXIT_SUCCESS;
}
\end{lstlisting}

Par contre, le code suivant va avoir un comportement al√©atoire pouvant mener presque certainement √† un plantage du code :

\begin{lstlisting}{caption=Exemple invalide de retour d'une r√©f√©rence par une fonction}
#include <iostream>
#include <cmath>

// La fonction n'est pas valide car on retourne 
double& max_root_quadratic_function(double a, double b, double c)
{
  assert(a!= 0);
  double delta = b*b-4*a*c;
  double sol;
  if (delta  < 0) sol = std::nan;
  else if (delta == 0) sol =  -b/(2*a);
  else sol = (-b+std::sqrt(delta))/2;

  return sol; // Erreur, on retourne une variable locale en r√©f√©rence
}

int main()
{
    double& root = max_root_quadratif_function(1,2,-3);
    std::cout << "Racine max de x¬≤+2x-3 : " << root << std::endl;
    return EXIT_SUCCESS;
}
\end{lstlisting}

En effet, la variable |sol| est locale √† la fonction |max\_root\_quadratic\_function| et sera par cons√©quent d√©truite √† la sortie de la fonction. La r√©f√©rence retourn√©e sera donc une r√©f√©rence sur une variable qui n'existe plus !

\subsubsection{Passage par r√©f√©rence}

En C, pour √©viter une copie d'une variable contenant beaucoup de donn√©es (typiquement une grosse structure de donn√©e), ou pour modifier √† la sortie d'une fonction un argument pass√© √† la fonction, il fallait obligatoirement passer par un pointeur :

\begin{lstlisting}[caption=fonction C avec modification des arguments d'entr√©e]
#include <iostream>

void iter_syracuse(int* un)
{
    if ((*un)%2 == 0) (*un) /= 2;
    else (*un) = (3*(*un)+1)/2;
}

int main()
{
    std::cout << "Suite de syracuse : ";
    int n = 1433;
    std::cout << n << " ";
    while (n != 1)
    {
        iter_syracuse(&n);
        std::cout << n << " ";
    }
    std::cout << std::endl;
    return EXIT_SUCCESS;
}
\end{lstlisting}

Plusieurs remarques √† propos du code C :
\begin{enumerate}
    \item La manipulation d'un pointeur dans la fonction la rend peu lisibile (confusion possible entre le signe multipli√© et le symbole de d√©f√©rencement);
    \item Le code n'est pas s√ªr : que se passe-t'il si le pointeur est nul ? o√π bien pointe sur une variable qui n'existe pas ?
\end{enumerate}

On peut bien s√ªr v√©rifier que le pointeur est non nul √† l'aide d'une assertion dans la fonction (valable aussi en C) :
\begin{lstlisting}[caption=fonction C avec modification des arguments d'entr√©e]
#include <iostream>
#include <cassert>

void iter_syracuse(int* un)
{
    // Pr√©condition
    // En mode debug, (-DDEBUG ou -g √† la compilation), arr√™te le programme si la condition n'est pas v√©rifi√©e
    assert(un != nullptr); 
    assert((*un) > 0);

    if ((*un)%2 == 0) (*un) /= 2;
    else (*un) = (3*(*un)+1)/2;
    // Postcondition
    assert((*un) > 0);
}
\end{lstlisting}

\underline{Remarques} : 
\begin{enumerate}
    \item √Ä partir du C++ 11, la macro |NULL| du C a √©t√© remplac√© avantageusement par un objet |nullptr| poss√©dant son propre type. C'est particuli√®rement utile lors de l'√©criture de fonctions template.
    \item Rappelons qu'il est vivement conseill√© d'utiliser des assertions dans son code, principalement pour les pr√© et post-conditions ! Cela permet de gagner un temps fou √† la phase de d√©bogage du code. 
\end{enumerate}

En C++, on peut remplacer avantageusement le pointeur par une r√©f√©rence pour le param√®tre de la fonction :
\begin{lstlisting}[caption=fonction C avec modification des arguments d'entr√©e]
#include <iostream>
#include <cassert

void iter_syracuse(int& un)
{
    // Pr√©condition
    assert(un > 0);

    if (un%2 == 0) un /= 2;
    else un = (3*un+1)/2;

    // Postcondition
    assert(un > 0);
}

int main()
{
    std::cout << "Suite de syracuse : ";
    int n = 1433;
    std::cout << n << " ";
    while (n != 1)
    {
        iter_syracuse(n);
        std::cout << n << " ";
    }
    std::cout << std::endl;
    return EXIT_SUCCESS;
}
\end{lstlisting}

Lors de l'appel √† la fonction, le param√®tre |un| devient un alias du param√®tre |n| pass√© √† la fonction. Par contre, il est obligatoire dans le cas d'une simple r√©f√©rence de passer une variable et non directement une valeur √† la fonction, puisque
|un| doit devenir un alias d'une variable. Ainsi |iter_syracuse(1433)| g√©n√©rerait une erreur du compilateur.

L'usage de la r√©f√©rence dans la fonction a donc permis :
\begin{enumerate}
    \item D'√©crire un code beaucoup plus clair puisqu'on n'utilise plus de symbole de d√©f√©rencement;
    \item D'avoir un code plus s√ªr puisque le m√©canisme de la r√©f√©rence nous oblige √† appeler la fonction avec une variable
    pr√©-existante.
\end{enumerate}

Le deuxi√®me usage de la r√©f√©rence, √† l'instar des pointeurs, et de pouvoir passer un param√®tre dont le type contient beaucoup
de donn√©es sans effectuer une copie de ce param√®tre √† l'appel (rappelons que le C passe ses param√®tres par valeur). 
Passer en r√©f√©rence (ou en r√©f√©rence constante comme nous allons le voir ci--dessous), c'est l'√©quivalent de passer par adresse la variable. N√©anmoins, il existe plusieurs situations o√π on ne d√©sire pas que le param√®tre pass√© par r√©f√©rence puisse √™tre modifi√© par inadvertance par le programmeur. On utilise dans ce cas l√† une r√©f√©rence constante :

\begin{lstlisting}[caption=Exemple d'utilisation de la r√©f√©rence constante]
#include <iostream>
#include <cmath>

struct rational
{
    int nom;
    unsigned denom;
};

inline double eval(const rational& r)
{
    return r.nom/double(r.denom);
}

rational approx_rationnal(double x, const rational& pn, const rational& qn, double tol = 1.E-6 )
{
    rational median{.nom=pn.nom+qn.nom,.denom=pn.denom+qn.denom};
    double y = eval(median);
    if (std::abs(x-y) < tol) return median;
    if (y < x) return approx_rationnal(x, median, qn);
    else return approx_rationnal(x, pn, median);
}

int main()
{
    double x = std::acos(-1);

    auto rx = approx_rationnal(x, {.nom=int(x),.denom=1}, {.nom=int(x+1),.denom=1});
    std::cout << "Approximation de " << x << " par un rationnel -> " << rx.nom << "/" << rx.denom << std::endl;

    return EXIT_SUCCESS;
}
\end{lstlisting}

Plusieurs commentaires √† faire sur ce code :
\begin{enumerate}
    \item Les param√®tres de type |rational| ont bien √©t√© pass√©s par r√©f√©rence afin d'√©viter √† chaque coup une copie de deux entiers;
    \item La fonction |eval| a √©t√© d√©clar√©e |inline|. Cela permet d'√©viter la surcharge d'un appel de fonction pour une fonction ne faisant presque rien. |inline| permet de remplacer l'appel de la fonction directement par le code machine assembl√© pour la fonction. 
    \item Dans la fonction |main|, nous avons pass√© deux rationnels en valeur directement dans l'appel de la fonction ce qui est interdit dans le cas d'un passage par r√©f√©rence simple mais permis dans le cas d'un passage par r√©f√©rence constante ! En fait, passer par r√©f√©rence constante assure qu'on ne peut pas modifier ce param√®tre au sein de la fonction, et donc la fonction peut donc effectuer un alias en lecture seule avec les deux valeurs mises sur la pile d'appel (qu'on ne peut pas modifier).
\end{enumerate}

Enfin, le retour par une fonction d'un tableau de type |vector| n'effectue une copie du tableau retourn√©
que si la variable de type |vector| retourn√©e n'est pas locale √† la fonction, sinon
elle effectue un \textsl{d√©placement}, c'est √† dire que la variable recevant le retour de la fonction ``vole'' le pointeur et la m√©moire r√©serv√©e par la variable retourn√©e (ce qui n'a pas d'incidence puisque cette variable aurait d√ª √™tre d√©truite de toute fa√ßon\ldots :

\begin{lstlisting}[caption=retour d'une variable de type vector]
#include <vector>

// Retourne le plus grand des vecteurs :
vector bad_max(const vector& u, const vector& v)
{
  if (u>v) return u; else return v;
}

// Idem. Notez qu'on retourne une r√©f√©rence, valide ici puisque u et v ne sont pas local √† cette fonction
const vector& good_max(const vector& u, const vector& v)
{
  if (u>v) return u; else return v;
}


// Retourne l'addition de deux vecteurs
vector add(const vector& u, const vector& v)
{
  assert(u.size() == v.size());
  vector w(u.size());
  for ( std::size_t i = 0; i < u.size(); ++i )
  {
    w[i] = u[i] + v[i];
  }
  return w;
}

int main()
{
  vector u  = {1., 2., 3., 4., 5.};
  vector v  = {2., 3., 4., 5., 1.};
  // L'appel de bad_max provoque une copie au retour de la fonction car u et v ne sont
  // pas locaux √† la fonction bad_max.
  auto   w1 = bad_max(u,v);
  // Ici, pas de copie puisqu'on a retourn√© une r√©f√©rence constante par la foncton good_max;
  auto   w2 = good_max(u,v);
  // Et ici pas de copie puisqu'on le vecteur retourn√© est local √† la fonction add
  auto   w3 = add(u,v);
}
\end{lstlisting}

Comme on voit sur l'exemple ci--dessus, si on ne veut pas avoir une copie effectu√©e lors du retour d'une variable global d'une fonction, il suffit de retourner une r√©f√©rence (constante ou non, ou les deux en surchargeant la fonction pour les tableaux constants et les tableaux non constants) :

\begin{lstlisting}
// Surcharge de la fonction good_max pour avoir une r√©f√©rence si les deux tableaux ne sont pas constants
vector& good_max( vector& u, vector& v )
{
  if (u>v) return u; else return v;
}
\end{lstlisting}


Il existe bien d'autres m√©thodes pour les objets de type |vector|, dont vous pouvez trouver la documentation dans les deux sites  \verb@cppreference@et \verb@cplusplus.com@. La chose importante √† retenir est surtout que la lib√©ration de la m√©moire se fait de fa√ßon automatique d√®s que l'objet de type vecteur cesse d'√™tre visible.

\subsection{Surcharge des op√©rateurs}

De m√™me qu'il est possible de surcharger des fonctions avec de nouveaux types d√©finis par l'utilisateur, il est √©galement possible
de red√©finir les symboles 

\begin{center}
\verb@+ += - -= * *= / /= ++ -- () [] ! ~ & | ^ = == < > <= >= << >>@
\end{center} 

et d'autres encore, moins courants. N√©anmoins, l'ordre 
des op√©rateurs restent celui impos√© par le C et le C++, impossible de red√©finir les priorit√©s sur les op√©rateurs !

Notons de plus un op√©rateur suppl√©mentaire en C++ 20, l'op√©rateur "vaisseau spatial" |<=>| qui permet de regrouper en un seul op√©rateur tous les op√©rateurs de comparaison. Pour des soucis d'efficacit√©, il est n√©anmoins possible de surcharger cet op√©rateur par certains des op√©rateurs standards du C++ qui prendront la priorit√© sur l'op√©rateur "vaisseau spatial".

Pour apprendre √† manipuler la red√©finition des op√©rateurs, concevons une petite biblioth√®que manipulant des vecteurs dans $\mathbb{R}^{3}$, avec laquelle on pourra :
\begin{itemize}
  \item Additionner et soustraire
  \item Effectuer un produit scalaire ou vectoriel
  \item Effectuer une homoth√©tie
  \item Afficher le vecteur
  \item Pouvoir lire une composante du vecteur de deux mani√®res :
  \begin{itemize}
    \item Par composante : |double x = u.x;| par exemple
    \item Sous la mani√®re d'un tableau : |double x = u[0];| par exemple
  \end{itemize}
\end{itemize}

On verra ainsi au fur et √† mesure comment red√©finir certains op√©rateurs. Commen√ßons par d√©finir notre vecteur et la fa√ßon d'acc√©der aux composantes du vecteur :

\begin{lstlisting}[caption=d√©finition d'un vecteur en trois dimensions]
struct vecteur
{
  double x, y, z;
};

int main()
{
    vecteur u{.x = 3, .y = 5, .z = -1};
    vecteur v{.x = 5, .y = 1, .z =  7};
    std::cout << "vecteur u : " << u.x << ", " << u.y << ", " << u.z << std::endl;

    return EXIT_SUCCESS;
}
\end{lstlisting}

On peut donc d√©j√† avec cette simple d√©finition d√©finir des vecteurs et acc√©der √† leurs composantes. Pour acc√©der √† la mani√®re d'un tableau aux composantes des vecteurs, nous allons utiliser l'op√©rateur |[]|, un des rares op√©rateurs qui doit √™tre imp√©rativement √™tre d√©fini √† l'int√©rieur de la structure avec l'op√©rateur |()| (op√©rateur d'√©valuation) :

\begin{lstlisting}[caption=d√©finition d'un vecteur en trois dimensions avec op√©rateur d'acc√©s]
struct vecteur
{
    double x, y, z;

    // Le const √† la fin de la ligne ci--dessous signifie que cet op√©rateur marchera pour
    // un vecteur constant (ce qui n'est pas le cas si on ne met pas const √† la fin)
    double operator [] ( int i ) const
    {
        assert(i>=0);
        assert(i <3);
        if (i==0) return x;
        if (i==1) return y;
        assert(i==2);// Normalement toujours vrai !
        return z;
    }

    // Remarque: le C++ sait distingu√© les deux car celui au dessus est d√©fini pour
    // un vecteur constant et celui ci--dessous pour un vecteur non constant.
    // Notez que dans le cas non constant, on renvoie une r√©f√©rence sur l'√©l√©ment du
    // vecteur afin qu'il puisse √™tre modifiable (par exemple en √©crivant u[0] = 3.; )
    double& operator [] ( int i )
    {
        assert(i>=0);
        assert(i <3);
        if (i==0) return x;
        if (i==1) return y;
        assert(i==2);// Normalement toujours vrai !
        return z;        
    }
};

int main()
{
    vecteur u{.x = 3, .y = 5, .z = -1};
    vecteur v{.x = 5, .y = 1, .z =  7};
    std::cout << "vecteur u : " << u.x << ", " << u.y << ", " << u.z << std::endl;
    std::cout << "vecteur v : ";
    for (int i = 0; i < 3; ++i ) std::cout << v[i] << " ";
    std::cout << std::endl;

    return EXIT_SUCCESS;
}
\end{lstlisting}

Rajoutons maintenant l'addition de deux vecteurs √† l'aide du symbole |+| et la soustraction de deux vecteurs
√† l'aide du symbole |-| :

\begin{lstlisting}
vecteur operator + ( const vecteur& u, const vecteur& v )
{
  return vecteur{.x = u.x + v.x, 
                 .y = u.y + v.y, 
                 .z = u.z + v.z };
}

vecteur operator - ( const vecteur& u, const vecteur& v )
{
  return vecteur{.x = u.x - v.x, 
                 .y = u.y - v.y, 
                 .z = u.z - v.z };
}

int main()
{
  ...
  vecteur w;
  w = u + v;
  vecteur t;
  t = u - v;
}
\end{lstlisting}

Remarquons que le premier param√®tre repr√©sente le vecteur √† gauche du symbole |+| ou du symbole |-|, et le second celui √† droite. Lorsqu'on √©crit dans le |main| une ligne comme |w = u + v;|, cette ligne est directement traduite par le C++ en
|w = operator + (u,v);|.

De m√™me, il est aussi facile de d√©finir le produit scalaire √† l'aide du symbole \verb@|@, le produit vectoriel √† l'aide du symbole \verb@^@  et l'homoth√©tie √† l'aide du symbole \verb@*@ :
\begin{lstlisting}
double operator | ( const vecteur& u, const vecteur& v )
{
  return u.x*v.x + u.y*v.y + u.z*v.z;
}

vecteur operator ^ ( const vecteur& u, const vecteur& v )
{
  vecteur w;
  w.x = u.y*v.z - u.z*v.y;
  w.y = u.z*v.x - u.x*v.z;
  w.z = y.x*v.y - u.y*v.x;
  return w;
}

vecteur operator * ( double alpha, const vecteur& u )
{
  return vecteur{ .x = alpha * u.x,
                  .y = alpha * u.y,
                  .z = alpha * u.z };
}

int main()
{
  ...
  double scal = (u|v);
  vecteur orth = u^v;
  vecteur double_u = 2. * u;
  ...
}
\end{lstlisting}

Il ne nous reste plus qu'√† afficher le vecteur de la m√™me mani√®re qu'on affichera un entier, un double, etc.

\begin{lstlisting}
std::ostream& operator << ( std::ostream& out, const vecteur& u )
{
  out << "< " << u.x << ", " << u.y << ", " << u.z << " >";
  return out;
}

int main()
{
  ...
  std::cout << "Le vecteur u vaut : " << u << std::endl;
  ...
}
\end{lstlisting}

Le symbole |<<| est le symbole utilis√© en C++ pour d√©crire un flux vers un p√©riph√©rique de sortie (on aura le m√™me type
d'√©criture si on dirige le flux vers un fichier, une imprimante, etc.). Ce symbol utilis√© comme op√©rateur de flux (il peut
√©galement servir √† d'autre choses), prend √† gauche de l'op√©rateur une sortie (fichier, console, etc.) qui sera en C++
de type |std::ostream| et qui sera modifi√© (en avan√ßant dans le fichier par exemple), et √† droite par le type d'objet qu'on
veut utiliser. Le fait de renvoyer en retour de la fonction la sortie |out| permet de cha√Æner les op√©rateurs de flux.

En effet, si on d√©compose la ligne |std::cout << "Le vecteur u vaut : " << u << std::endl;|, cette ligne est traduite
comme suit par le C++ :
\begin{lstlisting}
  operator << ( operator <<  ( operator <<  (std::cout, "Le vecteur u vaut"), u     ), std::endl);
//                   |            |          std::ostream&,    char*          |            |
//                   |         std::ostream&                                ,vecteur       |
//              std::ostream&                                                        ,   char
\end{lstlisting}

ce qui montre que retourner une variable de type |std::ostream&| est n√©cessaire puisque l'op√©rateur attend √† gauche un objet de ce type.

Vous trouverez un exemple complet de ce qu'on vient d'exposer (avec un ou deux op√©rateur en plus) dans 
\href{run:./Exemples/exemple_vecteur_3d_struct.cpp}{\texttt{exemple\_vecteur\_3d\_struct.cpp}}.


Enfin, la variable it√©r√©e lors d'une boucle peut √™tre d√©clar√©e dans la partie d'initialisation de la boucle :
\begin{lstlisting}[caption=Initialisation d'une boucle]
for ( int i = 0; i < 10; ++i )
    for ( int j = 0; j < 10; ++j )
        ...
for ( int i = 0; i < 20; ++i )
    ...
\end{lstlisting}

Noter que si la variable d'indice en C++ est d√©clar√©e √† l'initialisation de la boucle, cette derni√®re est d√©clar√©e localement et n'est visible qu'au sein de la boucle :

\begin{lstlisting}[caption=localit√© de l'indice de boucle en C++]
    for ( int i = 0; i < 20; ++i )
    {
        ...
        int k  = i + 1; // OK, i est visible √† ce niveau
    }
    int j = i; // Erreur de compilation ! i n'existe plus
\end{lstlisting}

Nous verrons √©galement qu'il existe d'autres types de boucles en C++ permettant de s'affranchir de la gestion des indices.

\underline{\textbf{√Ä partir du C++ 11}}:

Il est autoris√© de d√©finir des structures, des classes ou des unions dans un corps de fonction. La visibilit√© de la structure sera celle du bloc dans laquelle elle a √©t√© d√©finie.

\begin{lstlisting}[caption=d√©claration d'une structure au sein d'une fonction (C++ 11 ou sup√©rieur)]
void f()
{
    struct triplet { double x,y,z; };

    triplet t{.x=2,.y=4,.z=5};// initialisation structure C++ 20 ou sup√©rieur

}
\end{lstlisting}

\subsection{Entr√©es/sorties}

En C (mais aussi en C++), l'affichage sur un terminal d'un texte se fait √† l'aide de la fonction \texttt{printf}
de la biblioth√®que \texttt{stdio.h} (\texttt{cstdio} en C++). Cependant, l'utilisation de cette fonction est loin d'√™tre facile
et peut √™tre g√©n√©ratrice de bogues :

\begin{lstlisting}
#include <cstdio> // En C++, mais on peut aussi inclure stdio.h, √ßa marche aussi
                  // Remarque : pas d'extension pour l'inclusion des fichiers en C++ !
int main()
{
    int n1 = 3;
    double x = 3.14;
    // Inversion de %d et %lg => bogue attendu et affichage bizarre
    printf("x = %d, n1 = %lg\n",x, n1);
    return 1;
}
\end{lstlisting}

En C++, il existe une biblioth√®que d'entr√©e sortie simplifiant grandement l'affichage sur terminal (mais aussi sur fichier) sans se pr√©occuper du type de valeurs √† afficher :

\begin{lstlisting}
#include <iostream> // Biblioth√®que de gestion d'entr√©e/sortie du C++

int main()
{
    int n1 = 3;
    double x = 3.14;
    // std::cout permet d'afficher sur un terminal la sortie standard
    // std::endl permet un retour √† la ligne pr√©c√©d√© par un flush pour forcer l'affichage
    std::cout << "Il est facile d'afficher du texte, mais aussi des variables comme x = " << x
              << " ou encore n1 = " << n1 << std::endl;
}
\end{lstlisting}

On peut √©galement formater les entr√©es sorties pour une pr√©cision donn√©e, un nombre de caract√®re fixe, etc.

Voici un exemple exhaustif des possibilit√©s de formatage :
\begin{lstlisting}
#include <iostream>
#include <iomanip> // Pour jouer avec le format des nombres

int main()
{
    double x = 3.141516;
    int    n = 63123;

    std::cout << n << " en hexadecimal donne " << std::hex << n << std::dec << std::endl;
    for ( int i = 5; i < 10; ++i )
        std::cout << std::setw(i) << n << std::endl;// Modif. nbre de caract√®re pour afficher n
    for ( int i = 5; i < 10; ++i )
        std::cout << std::setfill('0') << std::setw(i) << n << std::endl; // Idem mais remplissage par des z√©ros

    std::cout << std::setprecision(5) << x << std::endl;// Affichage de x avec une pr√©cision donn√©e
    std::cout << std::setprecision(9) << x << std::endl;
    std::cout << std::fixed;// Impose que le nombre de chiffre apr√®s la virgule soit fixe
    std::cout << std::setprecision(5) << x << std::endl;
    std::cout << std::setprecision(9) << x << std::endl;

    return 1;
}
\end{lstlisting}

Si on compile le programme, on trouve en sortie :
\begin{inverseverbatim}
63123 en hexadecimal donne f693
6312
 63123
  63123
   63123
    63123
63123
063123
0063123
00063123
000063123
3.1415
3.141516
3.14152
3.141516000
\end{inverseverbatim}

Enfin il est possible d'√©crire litt√©ralement un bool√©en plut√¥t que d'√©crire sa repr√©sentation enti√®re (1 ou 0) :

Le programme suivant :
\begin{lstlisting}
int number = 5;
bool is_even = (number % 2 == 0);
bool is_odd  = (number % 2 == 1);
std::cout << "Affichage standard des booleens : "  << std::endl;
std::cout << number << " est pair   ? " << is_even << std::endl;
std::cout << number << " est impair ? " << is_odd  << std::endl;
std::cout << "Affichage alphanumerique des booleens : " << std::endl;
std::cout << number << " est pair   ? " << std::boolalpha << is_even << std::endl;
std::cout << number << " est impair ? " << std::boolalpha << is_odd  << std::endl;
\end{lstlisting}

affichera :

\begin{inverseverbatim}
Affichage standard des booleens : 
5 est pair   ? 0
5 est impair ? 1
Affichage alphanumerique des booleens : 
5 est pair   ? false
5 est impair ? true
\end{inverseverbatim}
